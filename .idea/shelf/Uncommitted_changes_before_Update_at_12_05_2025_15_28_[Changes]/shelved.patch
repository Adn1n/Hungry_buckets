Index: src/ui/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>Titre du jeu : Hungry Buckets\r\n\r\nContributeurs :\r\n\r\nOmar SNANI : génération des assets, options_screen.py, arrow.py, player2.py, game.py\r\n\r\nCylia GOUCEM : codage des fichiers ecran.py, panier.py, config.py, game.py, PowerPoint\r\n\r\nTeddy RAME : codage des fichiers choix_joueur.py, ball.py, background.py, fenetre.py, game.py\r\n\r\nAdnan MOUBARAC : codage des fichiers menu_screen.py, player1.py, player2.py, game.py\r\n\r\nDescription :\r\nCe projet nous a permis d’utiliser les connaissances accumulées en python durant ce semestre, tout en nous offrant une bonne expérience dans le domaine du travail d’équipe, en nous répartissant les tâches entre chacun, tout en gardant un regard sur le travail des autres afin de pouvoir nous entraider et améliorer notre code.\r\n\r\nFonctionnalités principales :\r\nCe jeu est un jeu de basketball, dans lequel le joueur choisit son personnage et doit marquer le plus de paniers possible en un temps défini.\r\n\r\nTechnologies utilisées :\r\nNous avons utilisé C comme langage de programmation. Comme bibliothèque, nous avons utilisé Pygame.\r\nNous avons également utilisé des images au format PNG que nous avons nous-mêmes générées.\r\n\r\nInstallation :\r\n\r\nIl faut copier l’URL du Git, puis, dans notre projet PyCharm, aller dans \"File\", puis \"Project from Version Control\", et coller l’URL.\r\nCréer les différents fichiers vides que l’on viendra remplir plus tard, puis enregistrer les fichiers.\r\n\r\npour acceder au code des autre il faut push et pour envoyer notre code sur le git il faut pull.\r\n\r\nUtilisation :\r\nIl suffit de push le main,le jeu se lance alors dans une nouvelle fenetre.\r\n\r\n\r\n\r\nTitre du jeu : Hungry Buckets\r\nContributeurs :\r\nOmar SNANI : génération des assets, options_screen.py, arrow.py, player2.py, game.py\r\nCylia GOUCEM : codage du fichier ecran.py, panier.py, config.py, game.py, PowerPoint\r\nTeddy RAME : codage des fichiers choix_joueur.py, ball.py, background.py, fenetre.py, game.py\r\nAdnan MOUBARAC : codage des fichiers menu_screen.py, player1.py, player2.py, game.py\r\n\r\nDescription :\r\nCe projet nous a permis d'utiliser les connaissances accumulées en C durant ce semestre tout en nous permettant d'avoir une bonne expérience dans le domaine du travail d'équipe en nous séparant les tâches entre chacun, tout en gardant un regard sur le travail de l'autre afin de pouvoir nous entraider pour améliorer notre code.\r\n\r\nFonctionnalités principales :\r\nCe jeu est un jeu de basketball, \"Dans lequel le joueur choisit son personnage et doit marquer le plus de paniers possible en un temps défini.\"\r\n\r\nTechnologies utilisées :\r\nNous avons utilisé python comme langage de programmation. Comme bibliothèque nous avons utilisé Pygame. \"Nous avons également utilisé des images au format PNG que nous avons nous-mêmes générées.\"\r\n\r\nInstallation :\r\nIl faut copier l'URL du Git et rentrer dans notre projet PyCharm, aller dans \"File\" puis \"Project from Version Control\" et coller l'URL.\r\n\r\nCréer les différents fichiers vides qu'on viendra remplir plus tard, puis enregistrer les fichiers.\r\n\r\nUtilisation :\r\nIl suffit de push le code qu'on vient de coder et il s'enregistre directement sur Git. Il y a la commande push évoquée avant mais également la commande pull qui sert à récupérer les commandes, à l'inverse de push qui sert à ajouter les modifications.\r\n\r\nJournal de bord :\r\n\r\n3/02/2025 : choix du thème du jeu et calcul des équations de trajectoires\r\n10/02/2025 : installation de Pygame, prise de connaissance de la bibliothèque et répartition des tâches\r\n10/02/2025 : épreuves maths 3, premières fonctions terminées\r\n19/02/2025 : génération de tous les assets nécessaires\r\n3/03/2025 : fichiers background, config, finis\r\n17/03/2025 : fichiers arrow, panier, finis\r\n24/03/2025 : fichier fenêtre fini\r\n10/03/2025 : fichier ball fini\r\n29/03/2025 : fichiers players 1 et 2 finis\r\n6/04/2025 : fichier game fini\r\n9/04/2025 : documentation sur le jeu finie\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ui/README.md b/src/ui/README.md
--- a/src/ui/README.md	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ b/src/ui/README.md	(date 1747056387155)
@@ -46,7 +46,7 @@
 Ce jeu est un jeu de basketball, "Dans lequel le joueur choisit son personnage et doit marquer le plus de paniers possible en un temps défini."
 
 Technologies utilisées :
-Nous avons utilisé python comme langage de programmation. Comme bibliothèque nous avons utilisé Pygame. "Nous avons également utilisé des images au format PNG que nous avons nous-mêmes générées."
+Nous avons utilisé C comme langage de programmation. Comme bibliothèque nous avons utilisé Pygame. "Nous avons également utilisé des images au format PNG que nous avons nous-mêmes générées."
 
 Installation :
 Il faut copier l'URL du Git et rentrer dans notre projet PyCharm, aller dans "File" puis "Project from Version Control" et coller l'URL.
Index: src/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main.py b/hungry_goals/main.py
rename from src/main.py
rename to hungry_goals/main.py
--- a/src/main.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ b/hungry_goals/main.py	(date 1747056376643)
@@ -1,4 +1,4 @@
-from src.core.game import Game
+from hungry_goals.engine.game import Game
 
 if __name__ == "__main__":
     game = Game()
Index: src/entities/panier.py
===================================================================
diff --git a/src/entities/panier.py b/src/entities/panier.py
deleted file mode 100644
--- a/src/entities/panier.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ /dev/null	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
@@ -1,18 +0,0 @@
-import pygame
-from src.core.config import SCREEN_WIDTH, SCREEN_HEIGHT, BASKET_COLOR, BACKBOARD_COLOR
-#
-class Panier:
-    def __init__(self):
-        self.basket_rect = pygame.Rect(SCREEN_WIDTH - 120, SCREEN_HEIGHT - 200, 60, 12)
-        self.backboard_rect = pygame.Rect(SCREEN_WIDTH - 60, SCREEN_HEIGHT - 250, 10, 70)
-        self.hoop_center_rect = pygame.Rect(self.basket_rect.centerx - 15, self.basket_rect.bottom, 30, 20)
-
-    def draw(self, screen):
-        pygame.draw.rect(screen, BASKET_COLOR, self.basket_rect)
-        pygame.draw.rect(screen, BACKBOARD_COLOR, self.backboard_rect)
-        pygame.draw.rect(screen, (255, 0, 0), self.backboard_rect, 2)
-        pygame.draw.rect(screen, (255, 0, 0), self.basket_rect, 2)
-
-
-    def get_rects(self):
-        return self.backboard_rect, self.basket_rect, self.hoop_center_rect
\ No newline at end of file
Index: src/core/fenetre.py
===================================================================
diff --git a/src/core/fenetre.py b/src/core/fenetre.py
deleted file mode 100644
--- a/src/core/fenetre.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ /dev/null	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
@@ -1,17 +0,0 @@
-import pygame
-from src.core.config import SCREEN_WIDTH, SCREEN_HEIGHT
-#
-class Fenetre:
-    def __init__(self, title="My Game", resizable=True):
-        flags = pygame.RESIZABLE if resizable else 0
-        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), flags)
-        pygame.display.set_caption(title)
-
-    def get_screen(self):
-        return self.screen
-
-    def clear(self, color):
-        self.screen.fill(color)
-
-    def update(self):
-        pygame.display.flip()
\ No newline at end of file
Index: src/entities/arrow.py
===================================================================
diff --git a/src/entities/arrow.py b/src/entities/arrow.py
deleted file mode 100644
--- a/src/entities/arrow.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ /dev/null	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
@@ -1,34 +0,0 @@
-import pygame
-import math
-
-#
-class Arrow:
-    def __init__(self, gravity=0.5, color=(0, 0, 0), width=2, length_factor=0.5):
-        self.gravity = gravity
-        self.color = color
-        self.width = width
-        self.length_factor = length_factor
-
-    def draw(self, surface, player_pos, start_pos, mouse_pos):
-        dx = start_pos[0] - mouse_pos[0]
-        dy = start_pos[1] - mouse_pos[1]
-
-        angle = math.atan2(dy, dx)
-        distance = math.hypot(dx, dy)
-        power = min(distance / 4, 20)
-
-        vel_x = math.cos(angle) * power
-        vel_y = math.sin(angle) * power
-
-        num_points = int(30 * (power / 20) * self.length_factor)
-        num_points = max(5, min(60, num_points))
-        time_interval = 0.05 + (power / 30)
-
-        for i in range(1, num_points + 1):
-            t = i * time_interval
-            dx = vel_x * t
-            dy = vel_y * t + 0.5 * self.gravity * t * t
-            point_x = player_pos[0] + dx
-            point_y = player_pos[1] + dy
-            if 0 < point_x < surface.get_width() and 0 < point_y < surface.get_height():
-                pygame.draw.circle(surface, self.color, (int(point_x), int(point_y)), 4)
\ No newline at end of file
Index: code_omar/high_scores.txt
===================================================================
diff --git a/code_omar/high_scores.txt b/code_omar/high_scores.txt
deleted file mode 100644
--- a/code_omar/high_scores.txt	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ /dev/null	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
@@ -1,1 +0,0 @@
-8
Index: src/core/config.py
===================================================================
diff --git a/src/core/config.py b/src/core/config.py
deleted file mode 100644
--- a/src/core/config.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ /dev/null	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
@@ -1,17 +0,0 @@
-import pygame
-import os
-
-#
-SCREEN_WIDTH, SCREEN_HEIGHT = 1000, 600
-
-WHITE = (255, 255, 255)
-BLACK = (0, 0, 0)
-BASKET_COLOR = (255, 100, 100)
-BACKBOARD_COLOR = (100, 100, 100)
-
-PLAYER_Y = SCREEN_HEIGHT - 100
-GRAVITY = 0.5
-
-
-BASE_DIR = os.path.dirname(os.path.dirname(__file__))
-ASSETS_DIR = os.path.join(BASE_DIR, "logo")
\ No newline at end of file
Index: src/core/game.py
===================================================================
diff --git a/src/core/game.py b/src/core/game.py
deleted file mode 100644
--- a/src/core/game.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ /dev/null	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
@@ -1,251 +0,0 @@
-import pygame
-import os
-import math
-import time
-import random
-
-from src.core.config import *
-from src.core.fenetre import Fenetre
-from src.entities.player1 import*
-from src.entities.player2 import*
-from src.entities.ball import Ball
-from src.entities.panier import Panier
-from src.entities.arrow import Arrow
-from src.ui.menu_screen import MenuScreen
-from src.ui.ecran import Ecran
-from src.ui.option_screen import OptionScreen
-from src.ui.choix_joueur import ChoixJoueur
-
-#
-class Game:
-    def __init__(self):
-        pygame.init()
-
-        self.window = Fenetre("Hungry Goals")
-        self.screen = self.window.get_screen()
-        self.font = pygame.font.SysFont("comicsans", 30)
-
-
-        base_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../"))
-        icon_path = os.path.join(base_path, "assets", "image", "logo.png")
-        icon = pygame.image.load(icon_path)
-        pygame.display.set_icon(icon)
-
-        self.ecran = Ecran(self.screen)
-        self.ecran.show_loading_screen()
-
-        self.clock = pygame.time.Clock()
-
-        # Objets du jeu
-        self.player1 = Player1(random.randint(100, 3 * SCREEN_WIDTH // 4), PLAYER_Y)
-        self.player2 = Player2(random.randint(100, 3 * SCREEN_WIDTH // 4), PLAYER_Y)
-        self.arrow = Arrow()
-        self.panier = Panier()
-        self.menu = MenuScreen()
-        self.option_screen = OptionScreen()
-        self.choix_joueur = ChoixJoueur()
-
-        # État du jeu
-        self.ball_list = []
-        self.score = 0
-        self.high_scores = []
-        self.dragging = False
-        self.start_pos = None
-        self.game_started = False
-        self.game_over = False
-        self.start_time = None
-
-        self.option = False
-        self.afficher_choix_joueur = False
-
-
-        pygame.display.flip()
-
-
-    def run(self):
-        running = True
-        while running:
-
-            if self.option:
-                sound_btn_rect, music_btn_rect, back_btn_rect = self.option_screen.draw(self.screen)
-                pygame.display.flip()
-                for event in pygame.event.get():
-                    if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
-                        running = False
-                    elif event.type == pygame.MOUSEBUTTONDOWN:
-                        if sound_btn_rect.collidepoint(event.pos):
-                            print("Sound button clicked")
-                        elif music_btn_rect.collidepoint(event.pos):
-                            print("Music button clicked")
-                        elif back_btn_rect.collidepoint(event.pos):
-                            self.option = False
-                self.clock.tick(60)
-                continue
-
-            if self.afficher_choix_joueur:
-                axel_rect, tyson_rect = self.choix_joueur.draw(self.screen)
-                pygame.display.flip()
-                for event in pygame.event.get():
-                    if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
-                        running = False
-                    elif event.type == pygame.MOUSEBUTTONDOWN:
-                        if axel_rect.collidepoint(event.pos):
-                            self.start_time = time.time()
-                            self.game_started = True
-                            self.afficher_choix_joueur = False  # ✅ ajoute ça !
-                            self.player2 = Player2(random.randint(100, 3 * SCREEN_WIDTH // 4), PLAYER_Y)
-                            self.player = self.player2
-                        elif tyson_rect.collidepoint(event.pos):
-                            self.start_time = time.time()
-                            self.game_started = True
-                            self.afficher_choix_joueur = False  # ✅ ajoute ça !
-                            self.player1 = Player1(random.randint(100, 3 * SCREEN_WIDTH // 4), PLAYER_Y)
-                            self.player = self.player1
-                self.clock.tick(60)
-                continue  # ✅ empêche le menu de s'afficher par-dessus
-
-            if not self.game_started:
-                jouer_btn, options_btn, quitter_btn = self.menu.draw_start_screen(self.screen, SCREEN_WIDTH, SCREEN_HEIGHT)
-                pygame.display.flip()
-                for event in pygame.event.get():
-                    if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
-                        running = False
-                    elif event.type == pygame.MOUSEBUTTONDOWN:
-                        if jouer_btn.collidepoint(event.pos):
-                            self.afficher_choix_joueur = True
-                        elif options_btn.collidepoint(event.pos):
-                            self.option = True
-                        elif quitter_btn.collidepoint(event.pos):
-                            pygame.quit()
-                            exit()
-
-
-
-
-
-
-
-            if self.game_over:
-                btn = self.menu.draw_game_over(self.screen, SCREEN_WIDTH, SCREEN_HEIGHT, self.score, self.high_scores)
-                pygame.display.flip()
-                for event in pygame.event.get():
-                    if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE) :
-                        running = False
-                    elif event.type == pygame.MOUSEBUTTONDOWN and btn.collidepoint(event.pos):
-                        self.high_scores.append(self.score)
-                        self.reset_game()
-                self.clock.tick(60)
-                continue
-
-
-            # Gameplay
-            if not self.start_time:
-                continue
-
-            elapsed = time.time() - self.start_time
-            remaining = max(0, int(60 - elapsed))
-            if remaining <= 0:
-                self.high_scores.append(self.score)
-                self.game_over = True
-                continue
-
-            self.screen.fill(WHITE)
-
-            # Chrono
-            self.screen.blit(self.menu.font.render(f"Time: {remaining}", True, BLACK), (20, 20))
-            if remaining <= 3:
-                txt = self.menu.huge_font.render(str(remaining), True, BLACK)
-                self.screen.blit(txt, txt.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)))
-
-            # Input
-            keys = pygame.key.get_pressed()
-            self.player.handle_input(keys, SCREEN_WIDTH)
-
-            for event in pygame.event.get():
-                if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
-                    running = False
-
-                elif event.type == pygame.MOUSEBUTTONDOWN:
-                    self.start_pos = pygame.mouse.get_pos()
-                    self.dragging = True
-                    self.player.start_shoot()
-
-                elif event.type == pygame.MOUSEBUTTONUP and self.dragging:
-                    end_pos = pygame.mouse.get_pos()
-                    self.player.state = "idle"
-                    self.player.frames = self.player.frames_idle
-                    self.player.frame_index = 0
-
-                    if self.start_pos and self.start_pos != end_pos:
-                        player_pos = self.player.get_position()
-
-                        dx = self.start_pos[0] - end_pos[0]
-                        dy = self.start_pos[1] - end_pos[1]
-                        angle = math.atan2(dy, dx)
-                        power = min(math.hypot(dx, dy) / 4, 20)
-
-                        self.ball_list.append(Ball(player_pos[0], player_pos[1], angle, power))
-
-                    self.dragging = False
-                    self.start_pos = None
-
-
-            # Affichage
-            self.player.draw(self.screen)
-            self.panier.draw(self.screen)
-
-            # ➕ Flèche de visée quand on vise
-            # ➕ Flèche de visée quand on vise
-            if self.dragging and self.start_pos:
-                current_mouse_pos = pygame.mouse.get_pos()
-                player_pos = self.player.get_position()
-                self.arrow.draw(self.screen, player_pos, self.start_pos, current_mouse_pos)
-
-
-            backboard_rect, basket_rect, hoop_center_rect = self.panier.get_rects()
-
-            for ball in self.ball_list:
-                if ball.active:
-                    result = ball.update(GRAVITY, SCREEN_HEIGHT, backboard_rect, basket_rect, hoop_center_rect)
-                    if result == "score":
-                        self.score += 1
-                        new_y = random.randint(200, SCREEN_HEIGHT - 250)  # évite le haut et le bas
-                        self.panier.basket_rect.y = new_y
-                        self.panier.backboard_rect.y = new_y - 50  # ajuste selon ta hauteur
-                        self.panier.hoop_center_rect.y = self.panier.basket_rect.bottom
-
-                        self.panier.hoop_center_rect.x = self.panier.basket_rect.centerx - self.panier.hoop_center_rect.width // 2
-                        self.panier.hoop_center_rect.y = self.panier.basket_rect.bottom
-
-                    ball.draw(self.screen)
-
-            self.ball_list = [b for b in self.ball_list if b.active]
-
-            pos = pygame.mouse.get_pos()
-            afficher_texte(self.screen, self.font, f'Pos : {pos[0]}, {pos[1]}', (0, 0), 'red')
-
-
-            # Score & record
-            self.screen.blit(self.menu.font.render(f"Score: {self.score}", True, BLACK), (SCREEN_WIDTH - 200, 40))
-            record = max(self.high_scores) if self.high_scores else "-"
-            self.screen.blit(self.menu.font.render(f"Record: {record}", True, BLACK), (SCREEN_WIDTH - 200, 10))
-
-            pygame.display.flip()
-            self.clock.tick(60)
-
-        pygame.quit()
-
-    def reset_game(self):
-        self.ball_list = []
-        self.score = 0
-        self.start_time = time.time()
-        self.dragging = False
-        self.start_pos = None
-        self.game_started = True
-        self.game_over = False
-
-
-
-if __name__ == "__main__":
-    game = Game()
-    game.run()
Index: src/utils.py
===================================================================
diff --git a/src/utils.py b/src/utils.py
deleted file mode 100644
--- a/src/utils.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ /dev/null	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
@@ -1,32 +0,0 @@
-import pygame
-#
-
-def afficher_texte(ecran,font, texte, position, couleur):
-    rendu = font.render(texte, True, couleur)
-    ecran.blit(rendu, position)
-
-
-SCALE = 3  # à placer en haut si pas déjà défini
-
-def load_frames(sprite_sheet, row, num_frames, width, height):
-    frames = []
-    for i in range(num_frames):
-        frame = sprite_sheet.subsurface(pygame.Rect(i * width, row * height, width, height))
-        frame = pygame.transform.scale(frame, (width * SCALE, height * SCALE))
-        frames.append(frame)
-    return frames
-
-def update_animation(frame_index, frames, animation_speed):
-    frame_index += animation_speed
-    if frame_index >= len(frames):
-        frame_index = 0
-    return frame_index, frames[int(frame_index)]
-
-def load_combined_frames(sprite_sheet, rows, num_frames_per_row, width, height):
-    frames = []
-    for idx, row in enumerate(rows):
-        for i in range(num_frames_per_row[idx]):
-            frame = sprite_sheet.subsurface(pygame.Rect(i * width, row * height, width, height))
-            frame = pygame.transform.scale(frame, (width * SCALE, height * SCALE))
-            frames.append(frame)
-    return frames
Index: src/ui/option_screen.py
===================================================================
diff --git a/src/ui/option_screen.py b/src/ui/option_screen.py
deleted file mode 100644
--- a/src/ui/option_screen.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ /dev/null	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
@@ -1,35 +0,0 @@
-import os
-import pygame
-from pygame import mouse
-
-from src.core.config import *
-from src.utils import afficher_texte
-
-####
-class OptionScreen:
-    def __init__(self):
-        base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
-        image_path = os.path.join(base_path, "assets", "image", "option_screen.png")
-        self.background = pygame.image.load(image_path)
-        self.background = pygame.transform.scale(self.background, (SCREEN_WIDTH, SCREEN_HEIGHT))
-
-        self.font = pygame.font.SysFont("arial", 20)
-
-        # Rects cliquables (invisibles)
-        self.sound_btn = pygame.Rect(350, 260, 275, 70)
-        self.music_btn = pygame.Rect(350, 360, 275, 65)
-        self.back_btn = pygame.Rect(340, 460, 280, 50)  # ajuste selon la vraie position du bouton << BACK
-
-    def draw(self,screen):
-
-        img_option = self.background
-        screen.blit(img_option, (0, 0))
-
-        sound_btn_rect = self.sound_btn
-        music_btn_rect = self.music_btn
-        back_btn_rect = self.back_btn
-
-        pos = mouse.get_pos()
-        afficher_texte(screen,self.font,f'pos : {pos[0]}, {pos[1]}',(0,0),'white')
-
-        return sound_btn_rect, music_btn_rect, back_btn_rect
Index: src/ui/choix_joueur.py
===================================================================
diff --git a/src/ui/choix_joueur.py b/src/ui/choix_joueur.py
deleted file mode 100644
--- a/src/ui/choix_joueur.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ /dev/null	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
@@ -1,33 +0,0 @@
-import os
-import pygame
-
-from src.core.fenetre import Fenetre
-from src.utils import *
-from src.core.config import *
-
-#
-class ChoixJoueur():
-    def __init__(self):
-        base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
-        image_path = os.path.join(base_path, "assets", "image", "choix_joueur.png")
-        self.background = pygame.image.load(image_path)
-        self.background = pygame.transform.scale(self.background, (SCREEN_WIDTH, SCREEN_HEIGHT))
-
-        self.font = pygame.font.SysFont("arial", 20)
-
-        self.btn_rect_axel = pygame.Rect(560, 290, 230, 210)
-        self.btn_rect_tyson = pygame.Rect(225, 285, 220, 215)
-
-
-    def draw(self,screen):
-
-        img_option = self.background
-        screen.blit(img_option, (0, 0))
-
-        btn_axel = self.btn_rect_axel
-        btn_tyson = self.btn_rect_tyson
-
-        pos = pygame.mouse.get_pos()
-        afficher_texte(screen,self.font,f'pos : {pos[0]}, {pos[1]}',(0,0),'white')
-
-        return btn_axel, btn_tyson
\ No newline at end of file
Index: src/entities/player1.py
===================================================================
diff --git a/src/entities/player1.py b/src/entities/player1.py
deleted file mode 100644
--- a/src/entities/player1.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ /dev/null	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
@@ -1,81 +0,0 @@
-import pygame
-from src.utils import *
-import os
-#
-SCALE = 3  # ou 3 pour encore plus grand
-
-class Player1:
-    def __init__(self, x, y):
-        self.x = x
-        self.y = y
-        self.radius = 20
-        self.color = (0, 100, 255)
-        self.speed = 6
-        self.frame_index = 0
-        self.animation_speed = 0.4
-
-        base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
-        image_path = os.path.join(base_path, "assets", "image", "Character.png")
-        self.sprite_sheet = pygame.image.load(image_path).convert_alpha()
-
-        self.frames_idle = load_frames(self.sprite_sheet, row=2, num_frames=23, width=64, height=64)
-        self.frames_right = load_combined_frames(self.sprite_sheet, rows=[8, 9], num_frames_per_row=[7, 20], width=64,height=64)
-        self.frames_left = [pygame.transform.flip(f, True, False) for f in self.frames_right]  # dribble gauche
-
-        self.frames_shoot = load_frames(self.sprite_sheet,3, 5, width=64, height=64)
-        self.state = "idle"
-        self.shooting_done = False
-
-        self.frames = self.frames_idle
-        self.current_frame = self.frames_idle[self.frame_index]
-
-    def start_shoot(self):
-        if self.state != "shoot":
-            self.frames = self.frames_shoot
-            self.frame_index = 0
-            self.state = "shoot"
-            self.shooting_done = False
-
-
-    def handle_input(self, keys, screen_width):
-        if self.state == "shoot":
-            if not self.shooting_done:
-                self.frame_index, self.current_frame = update_animation(self.frame_index, self.frames,
-                                                                        self.animation_speed)
-                if int(self.frame_index) >= len(self.frames) - 1:
-                    self.frame_index = len(self.frames) - 1
-                    self.current_frame = self.frames[self.frame_index]
-                    self.shooting_done = True
-            return
-
-        moving = False
-
-        if keys[pygame.K_LEFT]:
-            if self.frames != self.frames_left:
-                self.frames = self.frames_left
-                self.frame_index = 0
-            self.x -= self.speed
-            moving = True
-
-        elif keys[pygame.K_RIGHT]:
-            if self.frames != self.frames_right:
-                self.frames = self.frames_right
-                self.frame_index = 0
-            self.x += self.speed
-            moving = True
-
-        else:
-            if self.frames != self.frames_idle:
-                self.frames = self.frames_idle
-                self.frame_index = 0
-
-        # Animation si déplacement ou idle
-        self.frame_index, self.current_frame = update_animation(self.frame_index, self.frames, self.animation_speed)
-        self.x = max(self.radius, min(screen_width - self.radius, self.x))
-
-
-    def draw(self, surface):
-        surface.blit(self.current_frame, (self.x - self.current_frame.get_width() // 2, self.y - self.current_frame.get_height() // 2))
-
-    def get_position(self):
-        return (self.x, self.y)
\ No newline at end of file
Index: code_omar/main.py
===================================================================
diff --git a/code_omar/main.py b/code_omar/main.py
deleted file mode 100644
--- a/code_omar/main.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ /dev/null	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
@@ -1,658 +0,0 @@
-import pygame
-import math
-import time
-import random
-import sys
-import os
-
-pygame.init()
-
-# Configuration
-WIDTH, HEIGHT = 1000, 600
-WHITE = (255, 255, 255)
-BLACK = (0, 0, 0)
-BASKET_COLOR = (255, 100, 100)
-BACKBOARD_COLOR = (100, 100, 100)
-PLAYER_Y = HEIGHT - 100
-GRAVITY = 0.5
-PLAYER_SPEED = 5
-ARCEAU_COLOR = (204, 0, 204)        # Rouge vif
-PANNEAU_COLOR = (46, 46, 184)
-
-screen = pygame.display.set_mode((WIDTH, HEIGHT))
-pygame.display.set_caption("Hungry Goals")
-
-BASE_DIR = os.path.dirname(os.path.abspath(__file__))
-icon_path = os.path.join(BASE_DIR, "assets", "image", "logo.png")
-icon = pygame.image.load(icon_path)
-pygame.display.set_icon(icon)
-
-font = pygame.font.SysFont(None, 36)
-font_big = pygame.font.SysFont(None, 48)
-font_huge = pygame.font.SysFont(None, 120)
-
-# Police style pixel art (ex: pour le score affiché dans le menu)
-pixel_font = pygame.font.Font(None, 48)  # Remplace None par le chemin si tu utilises une .ttf custom
-
-
-# Gestion des scores
-def load_high_scores(path="high_scores.txt"):
-    if not os.path.exists(path):
-        return 0
-    with open(path, "r") as f:
-        line = f.readline().strip()
-        return int(line) if line.isdigit() else 0
-
-
-def save_high_score(score, path="high_scores.txt"):
-    with open(path, "w") as f:
-        f.write(f"{score}\n")
-
-
-# Chargement de sprites
-def load_frames(sheet, row, num_frames, width, height, scale=3):
-    return [pygame.transform.scale(
-        sheet.subsurface(pygame.Rect(i * width, row * height, width, height)),
-        (width * scale, height * scale)
-    ) for i in range(num_frames)]
-
-# Ecrans
-def show_loading_screen():
-    bg = pygame.image.load("assets/image/chargement.png").convert()
-    bg = pygame.transform.scale(bg, (WIDTH, HEIGHT))
-
-    loading_rect = pygame.Rect(WIDTH // 2 - 150, HEIGHT - 100, 300, 20)
-    bar_color = (255, 0, 255)  # rose néon
-
-    for i in range(0, 301, 5):  # remplissage progressif
-        screen.blit(bg, (0, 0))
-        pygame.draw.rect(screen, (50, 0, 50), loading_rect)  # fond sombre
-        pygame.draw.rect(screen, bar_color, (loading_rect.x, loading_rect.y, i, loading_rect.height))
-        pygame.draw.rect(screen, (255, 255, 255), loading_rect, 2)  # contour blanc
-        pygame.display.flip()
-        pygame.time.delay(30)  # vitesse de chargement simulée
-
-
-
-
-def draw_start_screen():
-    bg = pygame.image.load("assets/image/menu.png")
-    bg = pygame.transform.scale(bg, (WIDTH, HEIGHT))
-    screen.blit(bg, (0, 0))
-
-    jouer_btn = pygame.Rect(330, 220, 305, 65)
-    options_btn = pygame.Rect(345, 305, 280, 50)
-    quitter_btn = pygame.Rect(370, 380, 230, 45)
-
-    # Zone du record
-    record_rect = pygame.Rect(405, 448, 167, 42)
-
-    # Recharge le meilleur score à chaque affichage
-    best_score = load_high_scores()
-    text_surface = pixel_font.render(f"Record : {best_score}", True, (0, 255, 255))
-    text_rect = text_surface.get_rect(center=record_rect.center)
-    screen.blit(text_surface, text_rect)
-
-    return jouer_btn, options_btn, quitter_btn
-
-
-
-
-def draw_option_screen():
-    bg = pygame.image.load("assets/image/options.png").convert()
-    bg = pygame.transform.scale(bg, (WIDTH, HEIGHT))
-    screen.blit(bg, (0, 0))
-    mouse_pos = pygame.mouse.get_pos()
-    mouse_text = font.render(f"{mouse_pos}", True, (200, 0, 200))  # même couleur que les pointillés
-    screen.blit(mouse_text, (10, HEIGHT - 30))  # en bas à gauche
-
-    return pygame.Rect(400, 230, 220, 60), pygame.Rect(400, 330, 220, 60), pygame.Rect(400, 430, 220, 60)
-
-
-def draw_choix_joueur_screen():
-    bg = pygame.image.load("assets/image/choix_joueur.png")
-    bg = pygame.transform.scale(bg, (WIDTH, HEIGHT))
-    screen.blit(bg, (0, 0))
-
-    # Rectangles cliquables selon les coordonnées fournies
-    retour_btn = pygame.Rect(46, 39, 201, 59)               # Bouton RETOUR
-    tyson_btn = pygame.Rect(164, 162, 282, 349)             # Zone de Tyson
-    axel_btn = pygame.Rect(552, 159, 286, 351)              # Zone d'Axel
-
-    return tyson_btn, axel_btn, retour_btn
-
-
-def draw_game_over(score, high_score, is_record=False, blink_timer=0, cumulative_score=0, final_mode=False):
-    VIOLET = (200, 0, 200)
-    bg = pygame.image.load("assets/image/you_win.png" if score > 12 else "assets/image/game_over.png").convert()
-    bg = pygame.transform.scale(bg, (WIDTH, HEIGHT))
-    screen.blit(bg, (0, 0))
-
-    y_text = 246
-    display_score = score + cumulative_score if final_mode else score
-
-    if is_record and (blink_timer // 20) % 2 == 0:
-        text = pixel_font.render(f"Nouveau record : {display_score}", True, VIOLET)
-    else:
-        text = pixel_font.render(f"Score : {display_score}", True, VIOLET)
-
-    text_rect = text.get_rect(center=(WIDTH // 2, y_text))
-    screen.blit(text, text_rect)
-
-    # Coordonnées souris (toujours affichées)
-    mouse_x, mouse_y = pygame.mouse.get_pos()
-    mouse_text = font.render(f"Mouse: ({mouse_x}, {mouse_y})", True, VIOLET)
-    screen.blit(mouse_text, (10, HEIGHT - 30))
-
-    # Bouton replay
-    btn = pygame.Rect(WIDTH - 160, HEIGHT - 80, 140, 50)
-    pygame.draw.rect(screen, (200, 200, 200), btn)
-    pygame.draw.rect(screen, BLACK, btn, 2)
-    replay_label = font.render("Replay", True, BLACK)
-    screen.blit(replay_label, replay_label.get_rect(center=btn.center))
-
-    return btn
-
-
-
-
-
-
-
-def detect_colored_rect(image, target_color):
-    """Renvoie un pygame.Rect englobant tous les pixels ayant la couleur spécifiée."""
-    mask = pygame.mask.from_threshold(image, target_color, (1, 1, 1, 255))
-    if mask.count() == 0:
-        return None
-    return mask.get_bounding_rects()[0]
-
-
-
-def draw_trajectory(surface, start_pos, angle, power, steps=20):
-    # Clone exact de la logique de Ball.__init__
-    x = float(start_pos[0])
-    y = float(start_pos[1])
-    vel_x = math.cos(angle) * power
-    vel_y = math.sin(angle) * power
-    radius = BALL_RADIUS
-
-    for _ in range(steps):
-        # Mise à jour position
-        x += vel_x
-        y += vel_y
-
-        # Affichage du point
-        if 0 <= x <= WIDTH and 0 <= y <= HEIGHT:
-            pygame.draw.circle(surface, (200, 0, 200), (int(x), int(y)), 4)
-        else:
-            break
-
-        # Gravité identique à Ball.update()
-        vel_y += GRAVITY
-
-        # Rebond identique au sol
-        if y + radius >= HEIGHT:
-            y = HEIGHT - radius
-            if abs(vel_y) > 1:
-                vel_y *= -0.5
-                vel_x *= 0.95
-            else:
-                break  # balle au sol, arrêt
-
-        # Rebond gauche/droite identique
-        if x - radius <= 0:
-            x = radius
-            vel_x *= -0.8
-        elif x + radius >= WIDTH:
-            x = WIDTH - radius
-            vel_x *= -0.8
-
-
-
-# Ball
-class Ball:
-    def __init__(self, x, y, angle, power):
-        self.x = x
-        self.y = y
-        self.vel_x = math.cos(angle) * power
-        self.vel_y = math.sin(angle) * power
-        self.active = True
-        self.rest_time = None
-        self.scored = False
-
-    def update(self):
-        if not self.active:
-            return
-        self.vel_y += GRAVITY
-        self.x += self.vel_x
-        self.y += self.vel_y
-
-        if self.y + BALL_RADIUS >= HEIGHT:
-            self.y = HEIGHT - BALL_RADIUS
-            if abs(self.vel_y) > 1:
-                self.vel_y *= -0.5
-                self.vel_x *= 0.95
-            else:
-                self.vel_y = 0
-                self.vel_x = 0
-                if self.rest_time is None:
-                    self.rest_time = time.time()
-
-        # Rebond côté gauche
-        if self.x - BALL_RADIUS <= 0:
-            self.x = BALL_RADIUS
-            self.vel_x *= -0.8  # rebond plus doux
-            self.vel_y *= 0.95  # légère perte d’énergie
-
-        # Rebond côté droit
-        elif self.x + BALL_RADIUS >= WIDTH:
-            self.x = WIDTH - BALL_RADIUS
-            self.vel_x *= -0.8
-            self.vel_y *= 0.95
-
-        if self.rect().colliderect(backboard_rect):
-            self.x -= self.vel_x
-            self.vel_x *= -0.7
-        if self.rect().colliderect(basket_rect):
-            self.x -= self.vel_x
-            self.vel_x *= -0.6
-        if self.rect().colliderect(hoop_center_rect) and self.vel_y > 0 and not self.scored:
-            self.active = False
-            self.scored = True
-            return "score"
-        if self.rest_time and time.time() - self.rest_time > 1.5:
-            self.active = False
-
-    def draw(self, surface):
-        surface.blit(ball_image, (int(self.x - BALL_RADIUS), int(self.y - BALL_RADIUS)))
-
-    def rect(self):
-        return pygame.Rect(self.x - BALL_RADIUS, self.y - BALL_RADIUS, BALL_RADIUS * 2, BALL_RADIUS * 2)
-
-
-def reposition_panier():
-
-    min_y = 200  # ← pour ne pas être collé en haut
-    max_y = int(HEIGHT * 0.75)  # ← moitié de l'écran : 300 si HEIGHT = 600
-    y = random.randint(min_y, max_y)
-
-    # Dimensions
-    basket_width = 70
-    basket_height = 10
-    backboard_width = 10
-    backboard_height = 70
-    hoop_width = 50
-    hoop_height = 12
-
-    # Repositionner
-    global basket_rect, backboard_rect, hoop_center_rect
-    basket_rect = pygame.Rect(WIDTH - 80, y, basket_width, basket_height)
-    backboard_rect = pygame.Rect(
-        basket_rect.right - backboard_width,
-        basket_rect.top - backboard_height + 10,
-        backboard_width,
-        backboard_height
-    )
-    hoop_center_rect = pygame.Rect(
-        basket_rect.centerx - hoop_width // 2,
-        basket_rect.bottom,
-        hoop_width,
-        hoop_height
-    )
-
-# Panier : initialise une première position dynamique
-reposition_panier()
-
-# Balle
-ball_image = pygame.image.load("assets/image/Ball.png").convert_alpha()
-ball_image = pygame.transform.scale(ball_image, (50, 50))
-BALL_RADIUS = ball_image.get_width() // 2
-
-background_game = pygame.image.load("assets/image/terrain.png").convert()
-background_game = pygame.transform.scale(background_game, (WIDTH, HEIGHT))
-
-def main():
-    show_loading_screen()
-    clock = pygame.time.Clock()
-    high_score = load_high_scores()
-    blink_timer = 0
-    VIOLET = (200, 0, 200)  # à déclarer une seule fois en haut si pas encore fait
-    show_rules_screen = False
-
-    current_player = None
-    on_option_screen = False
-    on_choix_joueur = False
-    game_started = False
-    game_over = False
-    is_new_record = False
-
-    is_challenge_mode = False
-    final_mode = False
-    final_screen_shown = False
-    final_screen_start = None
-    panier_timer = 0
-    cumulative_score = 0
-    show_intro_screen = False
-    intro_start_time = None
-
-    frame_index = 0
-    score = 0
-    ball_list = []
-    dragging = False
-    start_pos = None
-    preview_angle = None
-    preview_power = None
-    start_time = None
-    player_x = random.randint(100, 750)
-
-    running = True
-
-    while running:
-        blink_timer += 1
-
-        # === Intro écran noir "partie initiatrice"
-        if show_intro_screen:
-            if time.time() - intro_start_time < 2:
-                screen.fill(BLACK)
-                txt = font_big.render("Partie initiatrice", True, WHITE)
-                screen.blit(txt, txt.get_rect(center=(WIDTH // 2, HEIGHT // 2)))
-                pygame.display.flip()
-                clock.tick(60)
-                continue
-            else:
-                show_intro_screen = False
-                start_time = time.time()
-
-        # === Transition vers niveau final
-        if final_screen_shown:
-            if time.time() - final_screen_start < 2:
-                screen.fill(BLACK)
-                txt = font_big.render("Niveau final", True, WHITE)
-                screen.blit(txt, txt.get_rect(center=(WIDTH // 2, HEIGHT // 2)))
-                pygame.display.flip()
-                clock.tick(60)
-                continue
-            else:
-                final_screen_shown = False
-                is_challenge_mode = True
-                start_time = time.time()
-                score = 0
-                ball_list.clear()
-                reposition_panier()
-                player_x = random.randint(100, 750)
-                continue
-
-        # === Options
-        if on_option_screen:
-            bg = pygame.image.load("assets/image/options.png").convert()
-            bg = pygame.transform.scale(bg, (WIDTH, HEIGHT))
-            screen.blit(bg, (0, 0))
-
-            # Coordonnées de la souris
-            mouse_x, mouse_y = pygame.mouse.get_pos()
-            mouse_text = font.render(f"Mouse: {mouse_x}, {mouse_y}", True, (200, 0, 200))
-            screen.blit(mouse_text, (20, HEIGHT - 30))
-
-            pygame.display.flip()
-
-            for event in pygame.event.get():
-                if event.type == pygame.QUIT:
-                    save_high_score(high_score)
-                    running = False
-                elif event.type == pygame.MOUSEBUTTONDOWN:
-                    if pygame.Rect(316, 520, 329, 53).collidepoint(event.pos):  # Retour au menu
-                        on_option_screen = False
-                    elif pygame.Rect(315, 412, 327, 84).collidepoint(event.pos):  # Affiche le but du jeu
-                        show_rules_screen = True
-                        on_option_screen = False
-
-            clock.tick(60)
-            continue
-
-        if show_rules_screen:
-            screen.fill((0, 0, 0))  # Fond noir
-            font_rules = pygame.font.Font(None, 24)  # Police plus petite
-
-            lines = [
-                "But du jeu :",
-                "Bienvenue dans Hungry Goals ! Le but est simple : marque un maximum de paniers avant la fin du chrono.",
-                "Pour tirer, clique et fais glisser la souris à l’opposé de la direction du tir, puis relâche pour lancer la balle.",
-                "Mais attention... Chaque panier réussi tombe directement sur la tête d'une personne mauvaise.",
-                "Ces individus malveillants méritent leur punition, alors venge-toi habilement !",
-                "Mais fais attention à ne pas être confondu avec eux… ou tu pourrais bien te la prendre toi aussi.",
-                "Objectif bonus : Si tu marques 12 points ou plus lors de la première partie, tu débloques le niveau final :",
-                "un défi plus rapide, plus précis, et encore plus intense.",
-                "Conseil : Observe la trajectoire, dose ta puissance, et venge les justes... en visant les mauvais !"
-            ]
-
-            y = 134
-            for line in lines:
-                rendered = font_rules.render(line, True, (200, 0, 200))
-                rect = rendered.get_rect(center=(WIDTH // 2, y))
-                screen.blit(rendered, rect)
-                y += 30
-
-            # Quitter l’écran des règles en cliquant n’importe où
-            for event in pygame.event.get():
-                if event.type == pygame.QUIT:
-                    running = False
-                elif event.type == pygame.MOUSEBUTTONDOWN:
-                    show_rules_screen = False
-                    on_option_screen = True
-
-            # Coordonnées souris (bas gauche)
-            mouse_x, mouse_y = pygame.mouse.get_pos()
-            mouse_text = font.render(f"Mouse: ({mouse_x}, {mouse_y})", True, (200, 0, 200))
-            screen.blit(mouse_text, (10, HEIGHT - 30))
-
-            pygame.display.flip()
-            clock.tick(60)
-            continue
-
-        # === Choix joueur
-        if on_choix_joueur:
-            tyson_btn, axel_btn, retour_btn = draw_choix_joueur_screen()
-            pygame.display.flip()
-            for event in pygame.event.get():
-                if event.type == pygame.QUIT:
-                    running = False
-                elif event.type == pygame.MOUSEBUTTONDOWN:
-                    if tyson_btn.collidepoint(event.pos):
-                        current_player = "tyson"
-                        sprite_sheet = pygame.image.load("assets/image/Character.png").convert_alpha()
-                    elif axel_btn.collidepoint(event.pos):
-                        current_player = "axel"
-                        sprite_sheet = pygame.image.load("assets/image/Character2.png").convert_alpha()
-                    else:
-                        continue
-                    on_choix_joueur = False
-                    game_started = True
-                    show_intro_screen = True
-                    intro_start_time = time.time()
-            clock.tick(60)
-            continue
-
-        # === Menu principal
-        if not game_started:
-            jouer_btn, options_btn, quitter_btn = draw_start_screen()
-            pygame.display.flip()
-            for event in pygame.event.get():
-                if event.type == pygame.QUIT:
-                    save_high_score(high_score)
-                    running = False
-                elif event.type == pygame.MOUSEBUTTONDOWN:
-                    if jouer_btn.collidepoint(event.pos):
-                        on_choix_joueur = True
-                    elif options_btn.collidepoint(event.pos):
-                        on_option_screen = True
-                    elif quitter_btn.collidepoint(event.pos):
-                        save_high_score(high_score)
-                        pygame.quit()
-                        sys.exit()
-            clock.tick(60)
-            continue
-
-        # === Fin de partie
-        if game_over:
-            btn = draw_game_over(score, high_score, is_new_record, blink_timer, cumulative_score, final_mode)
-
-            pygame.display.flip()
-
-            menu_btn_you_win = pygame.Rect(372, 330, 244, 61)
-            replay_btn_you_win = pygame.Rect(378, 426, 248, 55)
-            menu_btn_game_over = pygame.Rect(328, 281, 344, 65)
-            replay_btn_game_over = pygame.Rect(332, 368, 338, 74)
-
-            for event in pygame.event.get():
-                if event.type == pygame.QUIT:
-                    save_high_score(high_score)
-                    running = False
-                elif event.type == pygame.MOUSEBUTTONDOWN:
-                    if score >= 12 and not final_mode:
-                        if replay_btn_you_win.collidepoint(event.pos):
-                            cumulative_score = score
-                            final_mode = True
-                            final_screen_shown = True
-                            final_screen_start = time.time()
-                            game_over = False
-                            continue
-                    elif final_mode and replay_btn_you_win.collidepoint(event.pos):
-                        game_over = False
-                        game_started = True
-                        score = 0
-                        show_intro_screen = True
-                        intro_start_time = time.time()
-                        final_mode = False
-                        cumulative_score = 0
-                        continue
-
-                    if menu_btn_you_win.collidepoint(event.pos) or menu_btn_game_over.collidepoint(event.pos):
-                        score = 0
-                        cumulative_score = 0
-                        final_mode = False
-                        game_started = False
-                        game_over = False
-                    elif final_mode and replay_btn_you_win.collidepoint(event.pos):
-                        # Fin du niveau final → on recommence tout depuis zéro
-                        cumulative_score = 0
-                        score = 0
-                        final_mode = False
-                        is_challenge_mode = False
-                        game_over = False
-                        game_started = True
-                        show_intro_screen = True
-                        intro_start_time = time.time()
-                        reposition_panier()
-                        ball_list.clear()
-                        player_x = random.randint(100, 750)
-                        continue
-
-
-            continue
-
-        # === Chrono & fin
-        elapsed = time.time() - start_time
-        remaining = max(0, int(60 - elapsed))
-        if remaining <= 0:
-            total_score = score + cumulative_score
-            if total_score > high_score:
-                save_high_score(total_score)
-                high_score = total_score
-                is_new_record = True
-            game_over = True
-            continue
-
-        # === Chargement sprites joueur
-        if current_player:
-            frames_idle = load_frames(sprite_sheet, 2, 23, 64, 64)
-            frames_run = load_frames(sprite_sheet, 8, 7, 64, 64) + load_frames(sprite_sheet, 9, 20, 64, 64)
-            frames_left = [pygame.transform.flip(f, True, False) for f in frames_run]
-
-        # === Rendu principal
-        screen.blit(background_game, (0, 0))
-        screen.blit(font.render(f"Time: {remaining}", True, VIOLET), (20, 20))
-
-        # Déplacement joueur
-        keys = pygame.key.get_pressed()
-        if keys[pygame.K_LEFT]:
-            player_x -= PLAYER_SPEED
-            direction = "left"
-        elif keys[pygame.K_RIGHT]:
-            player_x += PLAYER_SPEED
-            direction = "right"
-        else:
-            direction = "idle"
-
-        player_x = max(30, min(WIDTH - 30, player_x))
-        frames = frames_left if direction == "left" else frames_run if direction == "right" else frames_idle
-        frame_index += 0.3
-        if frame_index >= len(frames):
-            frame_index = 0
-        current_frame = frames[int(frame_index)]
-        player_y = PLAYER_Y
-        player_pos = (player_x, player_y)
-
-        # === Events
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                save_high_score(high_score)
-                running = False
-            elif event.type == pygame.MOUSEBUTTONDOWN:
-                start_pos = pygame.mouse.get_pos()
-                dragging = True
-            elif event.type == pygame.MOUSEMOTION and dragging:
-                current_mouse = pygame.mouse.get_pos()
-                dx = start_pos[0] - current_mouse[0]
-                dy = start_pos[1] - current_mouse[1]
-                preview_angle = math.atan2(dy, dx)
-                preview_power = min(math.hypot(dx, dy) / 5, 24)
-            elif event.type == pygame.MOUSEBUTTONUP and dragging:
-                end_pos = pygame.mouse.get_pos()
-                dx = start_pos[0] - end_pos[0]
-                dy = start_pos[1] - end_pos[1]
-                angle = math.atan2(dy, dx)
-                power = min(math.hypot(dx, dy) / 5, 24)
-                ball_list.append(Ball(player_x, player_y, angle, power))
-                dragging = False
-                preview_angle = None
-                preview_power = None
-
-        screen.blit(current_frame, (player_x - current_frame.get_width() // 2, player_y - current_frame.get_height() // 2))
-        pygame.draw.rect(screen, ARCEAU_COLOR, basket_rect)
-        pygame.draw.rect(screen, PANNEAU_COLOR, backboard_rect)
-
-        if is_challenge_mode:
-            now = pygame.time.get_ticks()
-            if now - panier_timer > 3000:
-                reposition_panier()
-                panier_timer = now
-
-        for ball in ball_list:
-            if ball.active:
-                if ball.update() == "score":
-                    score += 1
-                    reposition_panier()
-                    player_x = random.randint(100, 750)
-                ball.draw(screen)
-        ball_list = [b for b in ball_list if b.active]
-
-        if dragging and preview_angle is not None and preview_power is not None:
-            draw_trajectory(screen, player_pos, preview_angle, preview_power)
-
-        total_score = score + cumulative_score
-
-        screen.blit(font.render(f"Score: {score}", True, VIOLET), (WIDTH - 200, 40))
-        screen.blit(font.render(f"Total: {total_score}", True, VIOLET), (WIDTH - 200, 70))
-        screen.blit(font.render(f"Record: {high_score}", True, VIOLET), (WIDTH - 200, 10))
-
-        pygame.display.flip()
-        clock.tick(60)
-
-    save_high_score(high_score)
-    pygame.quit()
-
-
-
-
-if __name__ == "__main__":
-    main()
Index: src/entities/ball.py
===================================================================
diff --git a/src/entities/ball.py b/src/entities/ball.py
deleted file mode 100644
--- a/src/entities/ball.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ /dev/null	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
@@ -1,84 +0,0 @@
-import os
-import pygame
-import math
-import time
-#
-class Ball:
-    def __init__(self, x, y, angle, power):
-        self.x = x
-        self.y = y
-        self.vel_x = math.cos(angle) * power
-        self.vel_y = math.sin(angle) * power
-        self.active = True
-        self.rest_time = None
-        self.scored = False
-
-        base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
-        image_path = os.path.join(base_path, "assets", "image", "Ball.png")
-        self.ball_image = pygame.image.load(image_path)
-        self.ball_image = pygame.transform.scale(self.ball_image, (60, 60))  # Adjust size to match original ball
-
-    def update(self, gravity, screen_height, backboard_rect, basket_rect, hoop_center_rect):
-        if not self.active:
-            return
-
-            # Appliquer gravité et mouvement
-        self.vel_y += gravity
-        self.x += self.vel_x
-        self.y += self.vel_y
-
-        # Collision avec le sol
-        if self.y + 10 >= screen_height:
-            self.y = screen_height - 10
-            if abs(self.vel_y) > 1:
-                self.vel_y *= -0.5
-                self.vel_x *= 0.95
-            else:
-                self.vel_y = 0
-                self.vel_x = 0
-                if self.rest_time is None:
-                    self.rest_time = time.time()
-
-        # Collision avec les bords de l'écran
-        if self.x - 10 <= 0 or self.x + 10 >= 1000:
-            self.vel_x *= -0.6
-
-        # Collision avec le panneau
-        if self.rect().colliderect(backboard_rect):
-            self.x -= self.vel_x  * 1.2
-            self.y -= self.vel_y * 0.6
-            self.vel_x *= -0.7
-
-
-        # Collision avec l'anneau
-        if self.rect().colliderect(basket_rect):
-            if self.x < basket_rect.left + 5:
-                self.x = basket_rect.left - 10
-                self.vel_x *= -0.6
-            elif self.x > basket_rect.right - 5:
-                self.x = basket_rect.right + 10
-                self.vel_x *= -0.6
-
-        # Passage au centre du panier = score
-        if self.rect().colliderect(hoop_center_rect):
-            # Si la balle touche le panier par le bas => supprimer
-            if self.vel_y < 0:
-                self.active = False
-                return
-            if self.vel_y > 0 and not self.scored :
-                self.scored = True
-                self.active = False
-                return "score"
-
-        # Désactivation après repos
-        if self.rest_time and time.time() - self.rest_time >= 1.5:
-            self.active = False
-        pass
-
-
-
-    def draw(self, screen):
-        screen.blit(self.ball_image, (int(self.x) - 10, int(self.y) - 10))
-
-    def rect(self):
-        return pygame.Rect(self.x - 10, self.y - 10, 20, 20)
\ No newline at end of file
Index: src/ui/menu_screen.py
===================================================================
diff --git a/src/ui/menu_screen.py b/src/ui/menu_screen.py
deleted file mode 100644
--- a/src/ui/menu_screen.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ /dev/null	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
@@ -1,64 +0,0 @@
-import os
-import pygame
-from pygame import mouse
-
-from src.core.config import *
-from src.utils import *
-#
-class MenuScreen:
-    def __init__(self):
-        self.font = pygame.font.SysFont(None, 36)
-        self.big_font = pygame.font.SysFont(None, 48)
-        self.huge_font = pygame.font.SysFont(None, 120)
-        base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
-        image_path = os.path.join(base_path, "assets", "image", "menu.png")
-        self.menu_bg = pygame.image.load(image_path)
-        self.menu_bg = pygame.transform.scale(self.menu_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
-
-        self.btn_jouer = pygame.Rect(330, 220, 305, 65)
-        self.btn_options = pygame.Rect(345, 305, 280, 50)
-        self.btn_quitter = pygame.Rect(370, 380, 230, 45)
-
-    def draw_start_screen(self, screen, width, height):
-        bg = self.menu_bg.copy()
-        screen.blit(bg, (0, 0))
-
-        jouer_rect = self.btn_jouer
-        options_rect = self.btn_options
-        quitter_rect = self.btn_quitter
-
-
-        pos = mouse.get_pos()
-        afficher_texte(screen,self.font,f'Pos : {pos[0]}, {pos[1]}',(0,0),'white')
-
-        return jouer_rect, options_rect, quitter_rect
-
-    def draw_game_over(self, screen, width, height, score, high_scores):
-        screen.fill((255, 255, 255))
-        msg = self.big_font.render("Fin de la partie", True, (0, 0, 0))
-        screen.blit(msg, msg.get_rect(center=(width // 2, height // 2 - 120)))
-
-        score_msg = self.font.render(f"Score : {score}", True, (0, 0, 0))
-        screen.blit(score_msg, score_msg.get_rect(center=(width // 2, height // 2 - 60)))
-
-        label = self.font.render("Meilleurs scores :", True, (0, 0, 0))
-        screen.blit(label, label.get_rect(center=(width // 2, height // 2)))
-
-        high_scores_sorted = sorted(high_scores, reverse=True)[:3]
-        y_offset = 40
-        for i in range(3):
-            if i < len(high_scores_sorted):
-                text = f"{i+1}. {high_scores_sorted[i]}"
-            else:
-                text = f"{i+1}. -"
-            score_line = self.font.render(text, True, (0, 0, 0))
-            screen.blit(score_line, (width // 2 - 50, height // 2 + y_offset))
-            y_offset += 40
-
-        replay_btn = pygame.Rect(width - 160, height - 80, 140, 50)
-        pygame.draw.rect(screen, (200, 200, 200), replay_btn)
-        pygame.draw.rect(screen, (0, 0, 0), replay_btn, 2)
-        text = self.font.render("Rejouer", True, (0, 0, 0))
-        screen.blit(text, text.get_rect(center=replay_btn.center))
-
-        return replay_btn
\ No newline at end of file
Index: src/entities/player2.py
===================================================================
diff --git a/src/entities/player2.py b/src/entities/player2.py
deleted file mode 100644
--- a/src/entities/player2.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ /dev/null	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
@@ -1,82 +0,0 @@
-
-import pygame
-from src.utils import *
-import os
-#
-SCALE = 3  # ou 3 pour encore plus grand
-
-class Player2:
-    def __init__(self, x, y):
-        self.x = x
-        self.y = y
-        self.radius = 20
-        self.color = (0, 100, 255)
-        self.speed = 6
-        self.frame_index = 0
-        self.animation_speed = 0.4
-
-        base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
-        image_path = os.path.join(base_path, "assets", "image", "Character2.png")
-        self.sprite_sheet = pygame.image.load(image_path).convert_alpha()
-
-        self.frames_idle = load_frames(self.sprite_sheet, row=2, num_frames=23, width=64, height=64)
-        self.frames_right = load_combined_frames(self.sprite_sheet, rows=[8, 9], num_frames_per_row=[7, 20], width=64,height=64)
-        self.frames_left = [pygame.transform.flip(f, True, False) for f in self.frames_right]  # dribble gauche
-
-        self.frames_shoot = load_frames(self.sprite_sheet,3, 5, width=64, height=64)
-        self.state = "idle"
-        self.shooting_done = False
-
-        self.frames = self.frames_idle
-        self.current_frame = self.frames_idle[self.frame_index]
-
-    def start_shoot(self):
-        if self.state != "shoot":
-            self.frames = self.frames_shoot
-            self.frame_index = 0
-            self.state = "shoot"
-            self.shooting_done = False
-
-
-    def handle_input(self, keys, screen_width):
-        if self.state == "shoot":
-            if not self.shooting_done:
-                self.frame_index, self.current_frame = update_animation(self.frame_index, self.frames,
-                                                                        self.animation_speed)
-                if int(self.frame_index) >= len(self.frames) - 1:
-                    self.frame_index = len(self.frames) - 1
-                    self.current_frame = self.frames[self.frame_index]
-                    self.shooting_done = True
-            return
-
-        moving = False
-
-        if keys[pygame.K_LEFT]:
-            if self.frames != self.frames_left:
-                self.frames = self.frames_left
-                self.frame_index = 0
-            self.x -= self.speed
-            moving = True
-
-        elif keys[pygame.K_RIGHT]:
-            if self.frames != self.frames_right:
-                self.frames = self.frames_right
-                self.frame_index = 0
-            self.x += self.speed
-            moving = True
-
-        else:
-            if self.frames != self.frames_idle:
-                self.frames = self.frames_idle
-                self.frame_index = 0
-
-        # Animation si déplacement ou idle
-        self.frame_index, self.current_frame = update_animation(self.frame_index, self.frames, self.animation_speed)
-        self.x = max(self.radius, min(screen_width - self.radius, self.x))
-
-
-    def draw(self, surface):
-        surface.blit(self.current_frame, (self.x - self.current_frame.get_width() // 2, self.y - self.current_frame.get_height() // 2))
-
-    def get_position(self):
-        return (self.x, self.y)
\ No newline at end of file
Index: hungry_goals/entities/player2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/entities/player2.py b/hungry_goals/entities/player2.py
new file mode 100644
--- /dev/null	(date 1747056376640)
+++ b/hungry_goals/entities/player2.py	(date 1747056376640)
@@ -0,0 +1,164 @@
+# Hungry Buckets
+# Description : Ce fichier contient la classe Player2, qui gère l'affichage, les déplacements et les animations du second joueur.
+
+import pygame
+from hungry_goals.utils import *
+import os
+#
+SCALE = 3  # ou 3 pour encore plus grand
+
+class Player2:
+    def __init__(self, x, y):
+        """
+        Initialise un objet Player2 avec sa position, ses attributs et ses animations.
+
+        Paramètres:
+        x (int): Position initiale en x du joueur.
+        y (int): Position initiale en y du joueur.
+
+        Retour:
+        None
+        """
+        # Initialisation des attributs de position, taille, couleur, vitesse et animation
+        self.x = x
+        self.y = y
+        self.radius = 20
+        self.color = (0, 100, 255)
+        self.speed = 6
+        self.frame_index = 0
+        self.animation_speed = 0.4
+
+        # Chargement de la sprite sheet
+        base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+        image_path = os.path.join(base_path, "assets", "image", "Character2.png")
+        self.sprite_sheet = pygame.image.load(image_path).convert_alpha()
+
+        # Chargement des animations
+        self.frames_idle = load_frames(self.sprite_sheet, row=2, num_frames=23, width=64, height=64)
+        self.frames_right = load_combined_frames(self.sprite_sheet, rows=[8, 9], num_frames_per_row=[7, 20], width=64,height=64)
+        self.frames_left = [pygame.transform.flip(f, True, False) for f in self.frames_right]  # dribble gauche
+
+        self.frames_shoot = load_frames(self.sprite_sheet,3, 5, width=64, height=64)
+
+        self.frames_special = load_frames(self.sprite_sheet, row=7, num_frames=11, width=64, height=64)
+
+        # État initial
+        self.state = "idle"
+        self.shooting_done = False
+
+        self.frames = self.frames_idle
+        self.current_frame = self.frames_idle[self.frame_index]
+
+    def start_special(self):
+        """
+        Démarre l'animation spéciale du joueur.
+
+        Paramètres:
+        Aucun
+
+        Retour:
+        None
+        """
+        if self.state != "special":
+            self.frames = self.frames_special
+            self.frame_index = 0
+            self.state = "special"
+            self.shooting_done = False
+
+    def start_shoot(self):
+        """
+        Démarre l'animation de tir du joueur.
+
+        Paramètres:
+        Aucun
+
+        Retour:
+        None
+        """
+        if self.state != "shoot":
+            self.frames = self.frames_shoot
+            self.frame_index = 0
+            self.state = "shoot"
+            self.shooting_done = False
+
+
+    def handle_input(self, keys, screen_width):
+        """
+        Gère les entrées clavier pour déplacer le joueur et mettre à jour son animation.
+
+        Paramètres:
+        keys (list): Liste des touches pressées.
+        screen_width (int): Largeur de l'écran pour limiter le déplacement.
+
+        Retour:
+        None
+        """
+
+        # Si une animation de tir ou spéciale est en cours, on la joue jusqu'au bout sans interruption
+        if self.state in ["shoot", "special"]:
+            if not self.shooting_done:
+                # Met à jour l'animation image par image
+                self.frame_index, self.current_frame = update_animation(self.frame_index, self.frames,
+                                                                        self.animation_speed)
+                if int(self.frame_index) >= len(self.frames) - 1:
+                    # Arrête l'animation à la dernière image
+                    self.frame_index = len(self.frames) - 1
+                    self.current_frame = self.frames[self.frame_index]
+                    self.shooting_done = True
+            return  # On ne gère pas les déplacements pendant ces animations
+
+        moving = False  # Sert à détecter si le joueur bouge
+
+        # Gestion du déplacement vers la gauche
+        if keys[pygame.K_LEFT]:
+            if self.frames != self.frames_left:
+                self.frames = self.frames_left  # Active l'animation correspondante
+                self.frame_index = 0
+            self.x -= self.speed
+            moving = True
+
+        # Gestion du déplacement vers la droite
+        elif keys[pygame.K_RIGHT]:
+            if self.frames != self.frames_right:
+                self.frames = self.frames_right
+                self.frame_index = 0
+            self.x += self.speed
+            moving = True
+
+        # Si aucune touche directionnelle n’est pressée : on revient à l’état "idle"
+        else:
+            if self.frames != self.frames_idle:
+                self.frames = self.frames_idle
+                self.frame_index = 0
+
+        # Mise à jour de l'animation (idle ou déplacement)
+        self.frame_index, self.current_frame = update_animation(self.frame_index, self.frames, self.animation_speed)
+
+        # Empêche le joueur de sortir de l'écran horizontalement
+        self.x = max(self.radius, min(screen_width - self.radius, self.x))
+
+
+    def draw(self, surface):
+        """
+        Dessine le joueur sur la surface donnée.
+
+        Paramètres:
+        surface (pygame.Surface): Surface sur laquelle dessiner le joueur.
+
+        Retour:
+        None
+        """
+        self.rect = self.current_frame.get_rect(center=(self.x, self.y))  # ✅ crée le rect à jour
+        surface.blit(self.current_frame, self.rect)
+
+    def get_position(self):
+        """
+        Retourne la position actuelle du joueur.
+
+        Paramètres:
+        Aucun
+
+        Retour:
+        tuple: Position (x, y) du joueur.
+        """
+        return (self.x, self.y)
\ No newline at end of file
Index: hungry_goals/interfaces/menu_screen.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/interfaces/menu_screen.py b/hungry_goals/interfaces/menu_screen.py
new file mode 100644
--- /dev/null	(date 1747056376641)
+++ b/hungry_goals/interfaces/menu_screen.py	(date 1747056376641)
@@ -0,0 +1,102 @@
+# Projet : Hungry Buckets
+# Description : Gère les écrans de menu principal et d'écran de fin avec leurs boutons et affichages de score.
+
+import os
+import pygame
+from pygame import mouse
+
+from hungry_goals.engine.config import *
+from hungry_goals.utils import *
+from hungry_goals.engine.score_manager import *
+#
+class MenuScreen:
+    def __init__(self):
+        self.score_manager = ScoreManager()
+        self.font = pygame.font.SysFont(None, 36)
+        self.big_font = pygame.font.SysFont(None, 48)
+        self.huge_font = pygame.font.SysFont(None, 120)
+        base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+        image_path = os.path.join(base_path, "assets", "image", "menu.png")
+        self.menu_bg = pygame.image.load(image_path)
+        self.menu_bg = pygame.transform.scale(self.menu_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
+
+        self.btn_jouer = pygame.Rect(330, 220, 305, 65)
+        self.btn_options = pygame.Rect(345, 305, 280, 50)
+        self.btn_quitter = pygame.Rect(370, 380, 230, 45)
+
+    def draw_start_screen(self, screen, width, height):
+        """
+        Affiche l'écran de démarrage avec fond et boutons, et retourne leurs zones cliquables.
+
+        Paramètres:
+            screen (pygame.Surface): La surface sur laquelle dessiner.
+            width (int): Largeur de l'écran.
+            height (int): Hauteur de l'écran.
+
+        Retour:
+            tuple: Rectangles des zones cliquables pour jouer, options et quitter.
+        """
+        # Afficher le fond
+        bg = self.menu_bg.copy()
+        screen.blit(bg, (0, 0))
+
+        # Créer les zones de boutons
+        jouer_rect = self.btn_jouer
+        options_rect = self.btn_options
+        quitter_rect = self.btn_quitter
+
+
+        # ➕ Zone du record
+        record_rect = pygame.Rect(405, 448, 167, 42)
+
+        # Gérer l’affichage du record s’il existe
+        if os.path.exists("high_scores.txt"):
+            with open("high_scores.txt", "r") as f:
+                scores = [int(line.strip()) for line in f if line.strip().isdigit()]
+                if scores:
+                    best_score = max(scores)
+                    text_surface = self.font.render(f"Record : {best_score}", True, (0, 255, 255))
+                    text_rect = text_surface.get_rect(center=record_rect.center)
+                    screen.blit(text_surface, text_rect)
+
+        return jouer_rect, options_rect, quitter_rect
+
+    def draw_game_over(self, screen, width, height, score, high_score):
+        # --- Détection si un nouveau record est atteint ---
+        is_record = score > high_score
+
+        bg_path = None
+
+        # --- Sauvegarde du score si record ---
+        if is_record:
+            self.score_manager.save_high_score(score)
+
+        # --- Choix du fond selon le score ---
+        if score < 12:
+            bg_path = os.path.join("assets", "image", "game_over.png")
+        elif score >= 12:
+            bg_path = os.path.join("assets", "image", "game_win.png")
+
+        # --- Affichage du fond si disponible ---
+        if bg_path and os.path.exists(bg_path):
+            bg = pygame.image.load(bg_path).convert()
+            bg = pygame.transform.scale(bg, (width, height))
+            screen.blit(bg, (0, 0))
+
+        # --- Affichage des boutons et du score (selon succès ou échec) ---
+        if score >= 12:
+            btn_menu = pygame.Rect(380, 330, 240, 55)
+            btn_rejouer = pygame.Rect(380, 430, 240, 50)
+            text = self.big_font.render(f"Score : {score}", True, TEXT_COLOR)
+            screen.blit(text, text.get_rect(center=(width // 2, 250)))  # ajuste la hauteur si besoin
+            return btn_menu, btn_rejouer
+        else:
+            btn_menu = pygame.Rect(330, 280, 340, 65)
+            btn_rejouer = pygame.Rect(330, 370, 340, 65)
+            score_text = self.big_font.render(f"Score : {score}", True, TEXT_COLOR)
+            screen.blit(score_text, score_text.get_rect(center=(width // 2, 250)))
+            return btn_menu, btn_rejouer
+
+
+
+
Index: hungry_goals/interfaces/option_screen.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/interfaces/option_screen.py b/hungry_goals/interfaces/option_screen.py
new file mode 100644
--- /dev/null	(date 1747056376641)
+++ b/hungry_goals/interfaces/option_screen.py	(date 1747056376641)
@@ -0,0 +1,48 @@
+# Projet : Hungry Buckets
+# Description : Ce fichier gère l'écran des options, avec affichage des boutons son, musique et retour.
+
+import os
+import pygame
+from pygame import mouse
+
+from hungry_goals.engine.config import *
+from hungry_goals.utils import afficher_texte
+
+####
+class OptionScreen:
+    def __init__(self):
+        base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+        image_path = os.path.join(base_path, "assets", "image", "options.png")
+        self.background = pygame.image.load(image_path)
+        self.background = pygame.transform.scale(self.background, (SCREEN_WIDTH, SCREEN_HEIGHT))
+
+        self.font = pygame.font.SysFont("arial", 20)
+
+        # Rects cliquables (invisibles)
+        self.sound_btn = pygame.Rect(320, 195, 320, 80)
+        self.music_btn = pygame.Rect(320, 305, 320, 80)
+        self.rules_btn = pygame.Rect(320, 415, 320, 80)
+        self.back_btn = pygame.Rect(320, 515, 320, 60)  # ajuste selon la vraie position du bouton << BACK
+
+    def draw(self,screen):
+        """
+        Affiche l'écran des options et retourne les zones cliquables.
+
+        Paramètre:
+            screen: surface Pygame où dessiner l'écran.
+
+        Retour:
+            sound_btn_rect, music_btn_rect, back_btn_rect: pygame.Rect des boutons cliquables.
+        """
+        # Affichage du fond
+        img_option = self.background
+        screen.blit(img_option, (0, 0))
+
+        # Récupération des boutons cliquables
+        sound_btn_rect = self.sound_btn
+        music_btn_rect = self.music_btn
+        back_btn_rect = self.back_btn
+        rules_btn_rect = self.rules_btn
+
+
+        return sound_btn_rect, music_btn_rect, back_btn_rect,rules_btn_rect
Index: hungry_goals/interfaces/player_selection.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/interfaces/player_selection.py b/hungry_goals/interfaces/player_selection.py
new file mode 100644
--- /dev/null	(date 1747056376641)
+++ b/hungry_goals/interfaces/player_selection.py	(date 1747056376641)
@@ -0,0 +1,46 @@
+# Projet : Hungry Buckets
+# Description : Gère l’écran de sélection du joueur (affichage du fond et détection des clics sur les zones interactives).
+
+import os
+import pygame
+
+from hungry_goals.engine.window import Fenetre
+from hungry_goals.utils import *
+from hungry_goals.engine.config import *
+
+#
+class ChoixJoueur():
+    def __init__(self):
+        base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+        image_path = os.path.join(base_path, "assets", "image", "choix_joueur1.png")
+        self.background = pygame.image.load(image_path)
+        self.background = pygame.transform.scale(self.background, (SCREEN_WIDTH, SCREEN_HEIGHT))
+
+        self.font = pygame.font.SysFont("arial", 20)
+
+        self.btn_rect_axel = pygame.Rect(555, 160, 275, 345)
+        self.btn_rect_tyson = pygame.Rect(160, 160, 280, 345)
+        self.btn_rect_retour = pygame.Rect(50, 40, 195, 50)
+
+
+    def draw(self,screen):
+        """
+        Affiche l'écran de choix du joueur et retourne les zones cliquables.
+
+        Paramètres :
+            screen : surface Pygame sur laquelle dessiner l'écran.
+
+        Retour :
+            tuple : (btn_axel, btn_tyson, btn_retour) - les Rects représentant les zones de clic pour Axel, Tyson et Retour.
+        """
+        # Affichage du fond
+        img_option = self.background
+        screen.blit(img_option, (0, 0))
+
+        # Définition des boutons interactifs
+        btn_axel = self.btn_rect_axel
+        btn_tyson = self.btn_rect_tyson
+        btn_retour = self.btn_rect_retour
+
+        # Retour des zones cliquables
+        return btn_axel, btn_tyson, btn_retour
\ No newline at end of file
Index: src/ui/ecran.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/ui/ecran.py b/hungry_goals/interfaces/screen.py
rename from src/ui/ecran.py
rename to hungry_goals/interfaces/screen.py
--- a/src/ui/ecran.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ b/hungry_goals/interfaces/screen.py	(date 1747056376643)
@@ -1,7 +1,10 @@
+# Projet : Hungry Buckets
+# Description : Gère les écrans intermédiaires comme l'écran de chargement (affichage, durée, barre de progression).
+
 import pygame
 import time
 
-from src.utils import *
+from hungry_goals.utils import *
 import os
 
 #
@@ -12,16 +15,30 @@
         self.WIDTH, self.HEIGHT = screen.get_size()
 
     def show_loading_screen(self):
+        """
+        Affiche une image de chargement pendant un court délai avec une barre de progression.
+
+        Aucun paramètre.
+
+        Retourne rien.
+        """
+
+        # Chargement de l’image
         base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
         image_path = os.path.join(base_path, "assets", "image", "chargement.png")
         loading_image = pygame.image.load(image_path)
         loading_image = pygame.transform.scale(loading_image, (self.WIDTH, self.HEIGHT))
+
+        # Initialisation du temps et de la durée
         start_time = time.time()
-        duration = 3 # secondes
+        duration = 1 # secondes
 
+        # Création de la police
         font = pygame.font.SysFont("arial", 30)
 
+        # Boucle d’affichage
         while time.time() - start_time < duration:
+            # Gestion des événements utilisateur
             for event in pygame.event.get():
                 if event.type == pygame.QUIT:
                     pygame.quit()
@@ -31,23 +48,17 @@
                         pygame.quit()
                         exit()
 
-
+            # Affichage de l’image et de la barre de progression
             self.screen.fill((0, 0, 0))
             self.screen.blit(loading_image, (0, 0))
 
             progress = (time.time() - start_time) / duration
             progress_width = int(515 * progress)
 
-
-            pos = pygame.mouse.get_pos()
-            afficher_texte(self.screen, font, f'pos : {pos[0],pos[1]}', (0,0), "white")
             # barre de chargement
             pygame.draw.rect(self.screen, (255, 255, 255), (270, 515, 515, 15), 2)
             pygame.draw.rect(self.screen, (0, 255, 255), (270, 515, progress_width, 15))
 
+            # Mise à jour de l’affichage et régulation du framerate
             pygame.display.flip()
             self.clock.tick(60)
-
-
-
-
Index: high_scores.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/high_scores.txt b/high_scores.txt
new file mode 100644
--- /dev/null	(date 1747056376635)
+++ b/high_scores.txt	(date 1747056376635)
@@ -0,0 +1,1 @@
+56
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
new file mode 100644
--- /dev/null	(date 1747056376464)
+++ b/README.md	(date 1747056376464)
@@ -0,0 +1,194 @@
+# Hungry Buckets 
+
+## 1. Contributeurs
+
+Le projet **Hungry Buckets** a été réalisé par une équipe de quatre étudiants de l'EFREI :
+
+- **Adnan Moubarac** : Principal développeur de la physique du jeu (logique des rebonds, score, équation de trajectoire, POO, optimisation finale).
+- **Omar Snani** : Responsable interface utilisateur et manche finale (menus, transitions, logique de victoire/défaite, panier mobile).
+- **Cylia Goucem** : Testeuse, rédactrice et coordinatrice de suivi (README, carnet de bord, PPT, validation fonctionnelle).
+- **Teddy Rame** : Designer graphique (sprites, visuels IA, cohérence visuelle, support de présentation).
+
+---
+
+## 2. Présentation du Jeu
+
+**Hungry Buckets** est un jeu 2D d'adresse basé sur la physique. Le joueur doit marquer des paniers en lançant des balles via la **souris** (clic-glisser) avec angle et puissance ajustables.
+
+###  Deux Manches :
+
+- **Manche 1** : Panier statique repositionné après chaque panier marqué. Objectif : **12 points minimum**.
+- **Manche 2 (finale)** : Débloquée si score suffisant. Le panier **change de position toutes les 2 secondes**.
+
+###  Style
+Ambiance cyber, animations fluides, visuels générés par IA.
+
+---
+
+## 3. Fonctionnalités Clés
+
+-  **Tir basé sur la physique** : angle, vitesse initiale, gravité, rebonds gérés.
+-  **Prévisualisation de tir** : affichage en temps réel de la trajectoire via des points violets.
+-  **Panier dynamique** : mouvement aléatoire après réussite (manche 1) ou toutes les 2s (manche 2).
+-  **Choix de personnage** : deux personnages animés au choix (Tyson & Axel).
+-  **Menus complets** : menu principal, options, sélection du personnage, écran de fin.
+-  **Design personnalisé** : sprites IA, esthétique cyber, barre de chargement animée.
+
+---
+
+## 4. Technologies Utilisées
+
+- **Python 3**
+- **Pygame**
+- **Git / GitHub**
+- **Discord / WhatsApp**
+- **Outils IA** : génération de sprites/personnages
+
+---
+
+## 5. Installation
+
+### Prérequis
+
+- Python 3.8+
+- `pip` installé
+
+###  Cloner le dépôt
+
+```bash
+git clone https://github.com/Adn1n/Hungry_buckets.git
+cd Hungry_buckets
+```
+
+###  Installer les dépendances
+
+```bash
+pip install pygame
+```
+
+### ▶ Lancer le jeu
+
+```bash
+python src/utils/main.py
+```
+
+> ⚠️ Le dossier `assets/` (images & musiques) doit être à la racine du projet.
+
+---
+
+## 6. Utilisation
+
+- Naviguer dans les menus avec la souris
+- Choisir un personnage
+- **Clic-glisser** pour viser, **relâcher** pour tirer
+- Atteindre **12 points** → accéder à la manche finale
+- Continuer à marquer jusqu’à la fin du chrono
+
+---
+
+## 7. Documentation Technique
+
+### Algorithme Général
+
+1. Lancer le jeu (écran de chargement)
+2. Menu principal → sélection de personnage
+3. Manche 1 : tir & score avec panier repositionné
+4. Si `score ≥ 12` : passage à la manche 2
+5. Manche 2 : panier se déplace toutes les 2s
+6. Fin de partie : écran victoire/défaite + score
+
+### Fonctionnalités Principales (Modules)
+
+- **Moteur physique** : angle, force, gravité, rebonds
+- **Trajectoire** : calcul et affichage dynamique
+- **Sprites** : joueurs animés, effets visuels
+- **Menus** : transitions fluides, gestion des états
+- **Score** : comptabilisé uniquement si la balle entre par le haut
+
+---
+
+## 8. Gestion des Entrées et des Erreurs
+
+- Empêche les tirs hors écran
+- Détection précise des collisions
+- Exception prévue si `high_scores.txt` est manquant
+- Score uniquement validé sur tir « propre »
+
+---
+
+## 9. Bugs Connus
+
+- Collisions latérales parfois approximatives (selon rebond)
+- Résolutions petites peuvent altérer la visualisation de trajectoire
+
+---
+
+## 10. Journal de Bord (extraits)
+
+- **03/02/2025** : Brainstorming initial, contraintes du projet
+- **10/02** : Prototype plateforme (type Mario), premiers tests Pygame
+- **15/02 → 03/03** : Mini-jeux individuels (canon, shoot, saut)
+- **03/03** : Partage des jeux → projet plateforme lancé
+- **17 → 24/03** : Déplacements, tirs, intégration assets
+- **04/04** : Pivot → jeu de basket « Hungry Buckets »
+- **14 → 21/04** : Trajectoire, mécanique de tir, panier
+- **28/04** : Transitions, rebonds, sprites animés
+- **05/05** : Bonus pendules, panier mouvant, finalisation
+- **10/05** : Tests finaux, rendu, README, PPT
+
+---
+
+## 11. Tests et Validation
+
+### Méthodes
+
+-  Tests unitaires : fonctions de trajectoire
+-  Tests fonctionnels : menus, collisions, rebonds
+-  Tests utilisateurs : jouabilité, intuitivité
+
+### Résultats
+
+-  Score uniquement sur tir par le haut
+-  Prévisualisation précise
+-  Menus réactifs
+
+---
+
+## 12. Répartition des Tâches
+
+| Membre   | Tâches clés |
+|----------|-------------|
+| Cylia    | Documentation, carnet, tests |
+| Teddy    | Design graphique, IA, présentation |
+| Omar     | UI, transitions, manche finale |
+| Adnan    | Tir, architecture, POO, trajectoire |
+
+---
+
+## 13. Problèmes Rencontrés et Solutions
+
+| Problème                        | Solution apportée                                 |
+|--------------------------------|----------------------------------------------------|
+| Code complexe à gérer          | Passage en POO, modules clairs                    |
+| Collisions imprécises          | Ajustements manuels + recherche de ressources     |
+| Difficulté de coordination     | Outils de suivi (Discord, GitHub, planning)       |
+| Incohérences de trajectoire    | Unification des formules tir & affichage          |
+
+---
+
+## 14. Améliorations Futures
+
+- Ajouter un écran de crédits
+- Intégrer des missions avec objectifs
+- Skins personnalisables pour les personnages
+- Ajouter une musique de fond complète et des effets sonores
+
+---
+
+## 15. Conclusion
+
+Ce projet transverse a été une aventure intense, mêlant apprentissage, créativité et travail d'équipe. Chaque membre a contribué avec ses compétences pour produire un jeu original, esthétique, et techniquement solide.
+
+Il nous a préparés à affronter des projets plus complexes, tout en mettant en lumière l’importance de la planification, de la communication, et de l’adaptation.
+
+---
Index: hungry_goals/utils.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/utils.py b/hungry_goals/utils.py
new file mode 100644
--- /dev/null	(date 1747056376643)
+++ b/hungry_goals/utils.py	(date 1747056376643)
@@ -0,0 +1,105 @@
+# Projet : Hungry Buckets
+# Description : Fonctions utilitaires pour le projet : chargement de sprites, mise à jour d’animations, affichage de texte, détection de pixels colorés.
+
+import pygame
+import os
+import time
+import math
+
+from hungry_goals.engine.config import *
+
+base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+image_path = os.path.join(base_path, "assets", "image", "Ball.png")
+
+ball_image = pygame.image.load("assets/image/Ball.png")
+ball_image = pygame.transform.scale(ball_image, (50, 50))
+BALL_RADIUS = ball_image.get_width() // 2
+
+
+def afficher_texte(ecran,font, texte, position, couleur):
+    """
+    Affiche un texte sur l'écran à une position donnée.
+
+    Paramètres :
+    - ecran : surface pygame sur laquelle afficher le texte
+    - font : objet pygame.font.Font utilisé pour rendre le texte
+    - texte : chaîne de caractères à afficher
+    - position : tuple (x, y) indiquant la position d'affichage
+    - couleur : couleur du texte (tuple RGB)
+
+    Retour :
+    - Aucun
+    """
+    rendu = font.render(texte, True, couleur)
+    ecran.blit(rendu, position)
+
+
+SCALE = 3  # à placer en haut si pas déjà défini
+
+def load_frames(sprite_sheet, row, num_frames, width, height):
+    """
+    Charge une série de frames à partir d'une feuille de sprite.
+
+    Paramètres :
+    - sprite_sheet : surface pygame contenant la feuille de sprites
+    - row : ligne dans la feuille de sprite à extraire
+    - num_frames : nombre de frames à charger
+    - width : largeur d'une frame
+    - height : hauteur d'une frame
+
+    Retour :
+    - Liste de surfaces pygame correspondant aux frames chargées et mises à l'échelle
+    """
+    frames = []
+    # Boucle de chargement de frames
+    for i in range(num_frames):
+        frame = sprite_sheet.subsurface(pygame.Rect(i * width, row * height, width, height))
+        # Application des transformations (scale)
+        frame = pygame.transform.scale(frame, (width * SCALE, height * SCALE))
+        frames.append(frame)
+    return frames
+
+def update_animation(frame_index, frames, animation_speed):
+    """
+    Met à jour l'index d'animation et retourne la frame correspondante.
+
+    Paramètres :
+    - frame_index : index flottant actuel de la frame d'animation
+    - frames : liste des frames d'animation
+    - animation_speed : vitesse d'animation (incrément de l'index)
+
+    Retour :
+    - tuple (nouvel index de frame, frame pygame correspondant)
+    """
+    # Calcul d’index
+    frame_index += animation_speed
+    if frame_index >= len(frames):
+        frame_index = 0
+    return frame_index, frames[int(frame_index)]
+
+def load_combined_frames(sprite_sheet, rows, num_frames_per_row, width, height):
+    """
+    Charge des frames combinées à partir de plusieurs lignes d'une feuille de sprite.
+
+    Paramètres :
+    - sprite_sheet : surface pygame contenant la feuille de sprites
+    - rows : liste des indices de lignes à extraire
+    - num_frames_per_row : liste du nombre de frames par ligne
+    - width : largeur d'une frame
+    - height : hauteur d'une frame
+
+    Retour :
+    - Liste de surfaces pygame correspondant aux frames chargées et mises à l'échelle
+    """
+    frames = []
+    # Boucle de chargement de frames pour chaque ligne
+    for idx, row in enumerate(rows):
+        for i in range(num_frames_per_row[idx]):
+            frame = sprite_sheet.subsurface(pygame.Rect(i * width, row * height, width, height))
+            # Application des transformations (scale)
+            frame = pygame.transform.scale(frame, (width * SCALE, height * SCALE))
+            frames.append(frame)
+    return frames
+
+
+
Index: src/core/backgroung.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/core/backgroung.py b/hungry_goals/engine/backgroung.py
rename from src/core/backgroung.py
rename to hungry_goals/engine/backgroung.py
--- a/src/core/backgroung.py	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ b/hungry_goals/engine/backgroung.py	(date 1747056376635)
@@ -7,13 +7,20 @@
     """
 
     def __init__(self, image_path, width, height):
+
+        # Charge l'image à partir du chemin donné
         self.original = pygame.image.load(image_path)
+        # Redimensionne l'image chargée aux dimensions spécifiées
         self.current = pygame.transform.scale(self.original, (width, height))
 
     def resize(self, width, height):
         """Redimensionne l'image de fond quand la fenêtre est redimensionnée."""
+
+        # Met à jour l'image redimensionnée en fonction des nouvelles dimensions
         self.current = pygame.transform.scale(self.original, (width, height))
 
     def draw(self, surface):
         """Dessine l'image de fond sur la surface donnée."""
+
+        # Affiche l'image redimensionnée sur la surface spécifiée à la position (0,0)
         surface.blit(self.current, (0, 0))
\ No newline at end of file
Index: hungry_goals/engine/config.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/engine/config.py b/hungry_goals/engine/config.py
new file mode 100644
--- /dev/null	(date 1747056376635)
+++ b/hungry_goals/engine/config.py	(date 1747056376635)
@@ -0,0 +1,50 @@
+import pygame
+import os
+
+pygame.init()
+
+SCREEN_WIDTH, SCREEN_HEIGHT = 1000, 600  # Dimensions de la fenêtre du jeu (largeur x hauteur)
+
+
+WHITE = (255, 255, 255)  # Couleur blanche, utilisée pour les fonds ou textes clairs
+BLACK = (0, 0, 0)        # Couleur noire, souvent pour le texte ou les contours
+TEXT_COLOR = (0, 255, 255)  # Cyan clair (style rétro/néon) pour les textes visibles
+
+
+BASKET_COLOR = (255, 100, 100)  # Couleur rouge clair pour le panier
+BACKBOARD_COLOR = (100, 100, 100)  # Couleur grise pour le panneau du panier
+
+
+PLAYER_Y = SCREEN_HEIGHT - 100  # Position verticale fixe du joueur (au sol)
+GRAVITY = 0.5  # Force de gravité appliquée à la balle et autres objets
+
+
+PLAYER_SPEED = 5  # Vitesse horizontale du joueur
+ARCEAU_COLOR = (204, 0, 204)        # Couleur violet vif pour l'arceau (cerceau)
+PANNEAU_COLOR = (46, 46, 184)  # Couleur bleue sombre pour le panneau
+
+
+POINT_SCORE = 1  # Points gagnés par panier réussi
+TEMPS_JEU = 45  # Durée du jeu en secondes
+
+TEMPS_ADDITIONNEL = 3  # Temps supplémentaire accordé pour le bonus
+
+
+font = pygame.font.SysFont(None, 36)    # Police de base pour les textes
+font_big = pygame.font.SysFont(None, 48)    # Police plus grande pour titres ou scores
+font_huge = pygame.font.SysFont(None, 120)    # Police très grande pour affichages importants
+
+
+# Police style pixel art
+pixel_font = pygame.font.Font(None, 48)
+
+
+base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+image_path = os.path.join(base_path, "assets", "image", "Ball.png")
+
+ball_image = pygame.image.load(image_path)
+ball_image = pygame.transform.scale(ball_image, (50, 50))  # Ajuste la taille de la balle
+BALL_RADIUS = ball_image.get_width() // 2  # Rayon de la balle utilisé pour la détection
+
+BASE_DIR = os.path.dirname(os.path.dirname(__file__))
+ASSETS_DIR = os.path.join(BASE_DIR, "logo")  # Dossier contenant le logo
\ No newline at end of file
Index: hungry_goals/engine/game.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/engine/game.py b/hungry_goals/engine/game.py
new file mode 100644
--- /dev/null	(date 1747056376637)
+++ b/hungry_goals/engine/game.py	(date 1747056376637)
@@ -0,0 +1,539 @@
+import pygame
+import os
+import math
+import time
+import random
+
+from pygame import mouse
+
+from hungry_goals.engine.config import *
+from hungry_goals.utils import *
+from hungry_goals.engine.window import Fenetre
+from hungry_goals.entities.player1 import*
+from hungry_goals.entities.player2 import*
+from hungry_goals.entities.ball import Ball
+from hungry_goals.entities.hoop import Panier
+from hungry_goals.entities.arrow import Arrow
+from hungry_goals.interfaces.menu_screen import MenuScreen
+from hungry_goals.engine.backgroung import BackgroundManager
+from hungry_goals.interfaces.screen import Ecran
+from hungry_goals.interfaces.option_screen import OptionScreen
+from hungry_goals.interfaces.player_selection import ChoixJoueur
+from hungry_goals.engine.music_manager import MusicManager
+from hungry_goals.engine.score_manager import ScoreManager
+from hungry_goals.entities.bonus_item import BonusItem
+
+class Game:
+    # Classe principale du jeu : gère l'initialisation, la boucle principale, et la réinitialisation du jeu.
+
+    def __init__(self):
+        """
+        Initialise le jeu et ses principaux attributs : fenêtre, ressources, état du jeu, objets, musique, etc.
+        """
+        pygame.init()
+
+        # Initialisation de la fenêtre, police, et affichage
+        self.window = Fenetre("Hungry Goals")
+        self.screen = self.window.get_screen()
+        self.font = pygame.font.SysFont("comicsans", 30)
+
+        # Chargement des images et du fond
+        base_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../"))
+        icon_path = os.path.join(base_path, "assets", "image", "logo.png")
+        icon = pygame.image.load(icon_path)
+        pygame.display.set_icon(icon)
+        background_path = os.path.join(base_path, "assets", "image", "background.png")
+        self.background = BackgroundManager(background_path, SCREEN_WIDTH, SCREEN_HEIGHT)
+
+        # Écrans et chargement
+        self.ecran = Ecran(self.screen)
+        self.ecran.show_loading_screen()
+
+        # Horloge et temps de départ
+        self.start_time = time.time()
+        self.clock = pygame.time.Clock()
+
+        # Joueur actif (sera défini selon le choix)
+        self.player = None
+
+        # Objets principaux du jeu
+        self.player1 = Player1(random.randint(100, 3 * SCREEN_WIDTH // 4), PLAYER_Y)
+        self.player2 = Player2(random.randint(100, 3 * SCREEN_WIDTH // 4), PLAYER_Y)
+        self.arrow = Arrow()
+        self.panier = Panier()
+        self.menu = MenuScreen()
+        self.option_screen = OptionScreen()
+        self.choix_joueur = ChoixJoueur()
+
+        # Bonus et gestion du temps de spawn des bonus
+        self.bonus_items = []
+        self.last_bonus_spawn = time.time()
+
+        # États du jeu et variables de progression
+        self.ball_list = []
+        self.score = 0
+        self.dragging = False
+        self.start_pos = None
+        self.game_started = False
+        self.game_over = False
+        self.start_time = None
+        self.is_new_record = False
+        self.option = False
+        self.afficher_choix_joueur = False
+        self.preview_angle = None
+        self.preview_power = None
+        self.challenge_mode = False
+        self.final_screen_shown = False
+        self.final_screen_start = None
+        self.challenge_timer = 0
+        self.challenge_timer = time.time()
+        self.total_score = 0  # Score classique + challenge
+        pygame.display.flip()
+
+        # Gestion du score et de la musique
+        self.score_manager = ScoreManager()
+        self.high_score = self.score_manager.load_high_score()
+
+
+
+        music_path = os.path.join("assets", "sounds", "musique2.mp3")
+        # Crée un objet qui va gérer la musique du jeu
+        self.music = MusicManager(music_path)
+        self.music.play()
+
+
+    def run(self):
+        """
+        Boucle principale du jeu : gère les événements, l'affichage, la logique de gameplay, les menus et les états.
+        """
+        running = True
+
+        while running:
+
+            # Affiche un écran spécial "niveau final" pendant 2 secondes
+            if self.final_screen_shown:
+                # Si on est encore dans les 2 premières secondes après l'affichage
+                if time.time() - self.final_screen_start < 2:
+
+                    # Affiche l'image de transition
+                    image_path = os.path.join("assets", "image", "niveau_finale.png")
+
+                    challenge_img = pygame.image.load(image_path)
+                    challenge_img = pygame.transform.scale(challenge_img, (SCREEN_WIDTH, SCREEN_HEIGHT))  # adapte la taille si besoin
+
+                    self.screen.blit(challenge_img, challenge_img.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)))
+                    pygame.display.flip()
+                    self.clock.tick(60)
+                    continue
+
+                else:
+                    # Fin de l'écran de transition : active le mode challenge
+                    self.final_screen_shown = False
+                    self.challenge_mode = True # On passe au mode challenge
+                    self.start_time = time.time() # Redémarre le chrono
+                    self.total_score = self.score   # On sauvegarde le score avant challenge
+                    self.score = 0 # On remet à zéro pour la suite
+                    self.score_challenge = 0 # Démarre un score spécial (si utilisé)
+                    self.ball_list.clear() # Supprime les balles précédentes
+                    self.panier.repositionner() # Repositionne le panier
+                    continue
+
+            # Affiche le menu des options (musique, sons, retour)
+            if self.option:
+                sound_btn_rect, music_btn_rect, back_btn_rect, rules_btn_rect = self.option_screen.draw(self.screen)
+                pygame.display.flip()
+
+                for event in pygame.event.get():
+                    # Ferme le jeu depuis l'écran d'options
+                    if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
+                        total = self.total_score + self.score
+                        if total > self.high_score:
+                            self.score_manager.save_high_score(total)
+                            self.high_score = total
+                        running = False
+
+                    elif event.type == pygame.MOUSEBUTTONDOWN:
+
+                        # Si on clique sur le bouton du son
+                        if sound_btn_rect.collidepoint(event.pos):
+                            print("Sound button clicked")
+
+                        # Pause ou reprend la musique
+                        elif music_btn_rect.collidepoint(event.pos):
+                            if pygame.mixer.music.get_busy():
+                                self.music.pause()
+                            else:
+                                self.music.resume()
+
+                        # Retour au menu principal
+                        elif back_btn_rect.collidepoint(event.pos):
+                            self.option = False
+
+                        elif rules_btn_rect.collidepoint(event.pos):
+                            # Charge l'image des règles
+                            rules_image_path = os.path.join("assets", "image", "rules.png")
+                            rules_image = pygame.image.load(rules_image_path)
+                            rules_image = pygame.transform.scale(rules_image, (SCREEN_WIDTH, SCREEN_HEIGHT))
+
+                            # Définir la zone cliquable correspondant au bouton "Retour" DANS l'image
+                            # (ajuste ces valeurs à la position réelle de ton bouton dans l'image)
+                            return_click_zone = pygame.Rect(385, 540, 220, 40)
+
+
+
+                            viewing_rules = True
+                            while viewing_rules:
+                                self.screen.blit(rules_image, (0, 0))
+                                pos = mouse.get_pos()
+                                afficher_texte(self.screen, self.font, f'pos : {pos}', (0, 0), 'white')
+                                pygame.display.flip()
+
+                                for e in pygame.event.get():
+                                    if e.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
+                                        pygame.quit()
+                                        exit()
+                                    elif e.type == pygame.MOUSEBUTTONDOWN :
+                                        if return_click_zone.collidepoint(e.pos):
+                                            viewing_rules = False
+
+
+                self.clock.tick(60)
+                continue
+
+            # Affiche l'écran de sélection du joueur (Axel ou Tyson)
+            if self.afficher_choix_joueur:
+                axel_rect, tyson_rect, retour_rect = self.choix_joueur.draw(self.screen)
+                pygame.display.flip()
+
+                for event in pygame.event.get():
+                    # Fermer le jeu depuis cet écran
+                    if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
+                        running = False
+
+                    elif event.type == pygame.MOUSEBUTTONDOWN:
+
+                        # Choix du joueur Axel
+                        if axel_rect.collidepoint(event.pos):
+                            self.start_time = time.time()
+                            self.game_started = True
+                            self.afficher_choix_joueur = False
+                            self.player2 = Player2(random.randint(100, 3 * SCREEN_WIDTH // 4), PLAYER_Y)
+                            self.player = self.player2
+
+                        # Choix du joueur Tyson
+                        elif tyson_rect.collidepoint(event.pos):
+                            self.start_time = time.time()
+                            self.game_started = True
+                            self.afficher_choix_joueur = False
+                            self.player1 = Player1(random.randint(100, 3 * SCREEN_WIDTH // 4), PLAYER_Y)
+                            self.player = self.player1
+
+                        # Retour sans sélection : empêche de lancer le jeu sans joueur
+                        elif retour_rect.collidepoint(event.pos):
+                            self.start_time = None
+                            self.afficher_choix_joueur = False
+                            self.game_started = False
+                            self.player = None  # évite le crash si aucun joueur sélectionné
+                continue
+
+            # Affiche le menu principal du jeu (jouer, options, quitter)
+            if not self.game_started:
+                jouer_btn, options_btn, quitter_btn = self.menu.draw_start_screen(self.screen, SCREEN_WIDTH, SCREEN_HEIGHT)
+                pygame.display.flip()
+
+                for event in pygame.event.get():
+                    # Quitte le jeu depuis le menu
+                    if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
+                        total = self.total_score + self.score
+                        if total > self.high_score:
+                            self.score_manager.save_high_score(total)
+                            self.high_score = total
+                        running = False
+
+                    elif event.type == pygame.MOUSEBUTTONDOWN:
+
+                        if jouer_btn.collidepoint(event.pos):
+                            self.afficher_choix_joueur = True  # Ouvre l'écran de choix du joueur
+
+                        elif options_btn.collidepoint(event.pos):
+                            self.option = True  # Ouvre les options
+
+                        elif quitter_btn.collidepoint(event.pos):
+                            self.total_score = 0
+                            self.score = 0
+                            total = self.total_score + self.score
+                            if total > self.high_score:
+                                self.score_manager.save_high_score(total)
+                                self.high_score = total
+                            pygame.quit()
+                            exit()
+
+
+            # Affiche l'écran de fin de partie avec les scores et options
+            if self.game_over:
+                btn_menu, btn_rejouer = self.menu.draw_game_over(self.screen, SCREEN_WIDTH, SCREEN_HEIGHT, self.total_score + self.score,self.high_score)
+                pygame.display.flip()
+
+                # Quitte le jeu depuis l'écran Game Over
+                for event in pygame.event.get():
+                    if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
+                        total = self.total_score + self.score
+                        if total > self.high_score:
+                            self.score_manager.save_high_score(total)
+                            self.high_score = total
+                        running = False
+
+                    elif event.type == pygame.MOUSEBUTTONDOWN:
+                        # Sauvegarde du nouveau record si nécessaire
+                        total = self.total_score + self.score
+
+                        if total > self.high_score:
+                            self.score_manager.save_high_score(total)
+                            self.is_new_record = True
+                            self.high_score = total
+                            high_score = self.score
+                            total = self.total_score + self.score
+                            if total > self.high_score:
+                                self.score_manager.save_high_score(total)
+                                self.high_score = total
+
+                        if btn_menu.collidepoint(event.pos):
+                            # Retour au menu principal
+                            self.total_score = 0
+                            self.score = 0
+                            total = self.total_score + self.score
+                            if total > self.high_score:
+                                self.score_manager.save_high_score(total)
+                                self.high_score = total
+                            self.start_time = None
+                            self.game_over = False
+                            self.game_started = False
+                            self.player = None
+
+                        elif btn_rejouer.collidepoint(event.pos):
+                            # Redémarre une nouvelle partie
+                            self.total_score = 0
+                            self.score = 0
+                            total = self.total_score + self.score
+                            if total > self.high_score:
+                                self.score_manager.save_high_score(total)
+                                self.high_score = total
+                            self.reset_game()
+
+                self.clock.tick(60)
+                continue
+
+
+            # Partie principale du gameplay : gestion du temps, des entrées, de la physique, des collisions, de l'affichage
+
+            # Si la partie n'a pas encore commencé, on attend le lancement
+            if not self.start_time:  # On attend que la partie commence
+                continue
+
+            # Calcul du temps écoulé et du temps restant avant la fin de la partie
+            elapsed = time.time() - self.start_time  # Temps écoulé depuis le début de la partie
+            remaining = max(0, int(TEMPS_JEU - elapsed))  # Temps restant avant la fin (jamais négatif)
+
+            # Si le temps est écoulé, la partie est terminée
+            if remaining <= 0:  # Partie terminée si temps écoulé
+                total = self.total_score + self.score
+                if total > self.high_score:
+                    self.score_manager.save_high_score(total)
+                    self.high_score = total
+                    self.is_new_record = True
+
+                # Passage en mode challenge si le score est suffisant et qu'on n'est pas déjà en challenge
+                if self.score >= 12 and not self.challenge_mode:
+                    self.final_screen_shown = True
+                    self.final_screen_start = time.time()
+                    continue
+
+                self.game_over = True
+                continue
+
+            self.background.draw(self.screen)
+
+
+            # Affichage du chrono
+            chrono_text = self.menu.font.render(f"Time: {remaining}", True, TEXT_COLOR)
+            self.screen.blit(chrono_text, chrono_text.get_rect(center=(SCREEN_WIDTH // 2, 20)))
+            if remaining <= 3:
+                txt = self.menu.huge_font.render(str(remaining), True, (255, 0, 255))
+                self.screen.blit(txt, txt.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)))
+
+
+            # Gestion des entrées clavier et souris
+            keys = pygame.key.get_pressed()
+            self.player.handle_input(keys, SCREEN_WIDTH)
+            if keys[pygame.K_RETURN] and self.player.state != "special":
+                self.player.start_special()
+
+
+            # Gestion des événements (clavier, souris, fermeture, etc.)
+            for event in pygame.event.get():  # Parcours tous les événements pygame (clavier, souris, etc.)
+
+                if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
+                    total = self.total_score + self.score
+                    if total > self.high_score:
+                        self.score_manager.save_high_score(total)
+                        self.high_score = total
+                    running = False
+
+                elif event.type == pygame.MOUSEBUTTONDOWN:
+                    self.start_pos = pygame.mouse.get_pos()  # On enregistre la position de départ du tir (clic souris)
+                    self.dragging = True
+                    self.player.start_shoot()
+
+                elif event.type == pygame.MOUSEMOTION and self.dragging:
+                    current_mouse = pygame.mouse.get_pos()
+                    dx = self.start_pos[0] - current_mouse[0]
+                    dy = self.start_pos[1] - current_mouse[1]
+                    self.preview_angle = math.atan2(dy, dx)  # Calcule l'angle du tir selon le déplacement souris
+                    self.preview_power = min(math.hypot(dx, dy) / 5, 24)  # Calcule la puissance du tir (distance du drag)
+
+                elif event.type == pygame.MOUSEBUTTONUP and self.dragging:
+                    end_pos = pygame.mouse.get_pos()  # On enregistre la position de fin du tir (relâchement souris)
+                    self.player.state = "idle"
+                    self.player.frames = self.player.frames_idle
+                    self.player.frame_index = 0
+                    if self.start_pos and self.start_pos != end_pos:
+                        player_pos = self.player.get_position()
+                        dx = self.start_pos[0] - end_pos[0]
+                        dy = self.start_pos[1] - end_pos[1]
+                        angle = math.atan2(dy, dx)  # Calcule l'angle du tir selon le vecteur souris (départ-arrivée)
+                        power = min(math.hypot(dx, dy) / 5, 24)  # Calcule la puissance (distance de drag)
+                        self.ball_list.append(Ball(player_pos[0], player_pos[1], angle, power))
+                    self.dragging = False
+                    self.start_pos = None
+                    self.preview_angle = None
+                    self.preview_power = None
+
+
+            # Affichage du joueur, panier, et gestion du tir spécial
+            self.player.draw(self.screen)
+            self.panier.draw(self.screen)
+            if self.player.shooting_done and self.player.state == "special":
+                player_pos = self.player.get_position()
+                _, _, hoop_rect = self.panier.get_rects()
+                target_pos = hoop_rect.center
+                dx = target_pos[0] - player_pos[0] * 0.8
+                dy = target_pos[1] - player_pos[1] - 1500
+                angle = math.atan2(dy, dx)
+                power = 25
+                self.ball_list.append(Ball(player_pos[0], player_pos[1], angle, power))
+                self.player.state = "idle"
+
+
+            # --- Affichage de la flèche de visée pendant le drag ---
+            # Affiche une flèche qui indique la direction et la puissance du tir lorsque le joueur maintient le clic et vise.
+            # Cela aide le joueur à anticiper la trajectoire de la balle avant de tirer.
+            if self.dragging and self.start_pos:
+                current_mouse_pos = pygame.mouse.get_pos()
+                player_pos = self.player.get_position()
+                if self.preview_angle is not None and self.preview_power is not None:
+                    self.arrow.draw_trajectory(self.screen, player_pos, self.preview_angle, self.preview_power)
+
+
+            # --- Boucle de mise à jour des balles, gestion du score et effets ---
+            # Pour chaque balle active, on met à jour sa position, on vérifie les collisions avec le panier,
+            # et on gère le score, le repositionnement du panier, et les effets spéciaux éventuels.
+            backboard_rect, basket_rect, hoop_center_rect = self.panier.get_rects()
+
+            for ball in self.ball_list:
+                if ball.active:
+                    result = ball.update(GRAVITY, SCREEN_HEIGHT, backboard_rect, basket_rect, hoop_center_rect)
+
+                    if result == "score":
+                        self.score += POINT_SCORE  # Incrémente le score si la balle marque
+                        self.panier.repositionner()  # Repositionne le panier après chaque panier marqué
+                        player_x = random.randint(100, 750)
+
+                        # --- Effet de secousse pendant le mode challenge ---
+                        # Lorsqu'un panier est marqué en mode challenge, la scène "tremble" pour ajouter du dynamisme.
+                        if self.challenge_mode:
+                            self.player.x = random.randint(100, 750)
+
+                            for i in range(10):
+                                intensity = max(1, 6 - i)
+                                offset_x = random.randint(-intensity, intensity)
+                                offset_y = random.randint(-intensity, intensity)
+                                self.background.draw(self.screen)
+                                self.screen.scroll(offset_x, offset_y)
+                                self.player.draw(self.screen)
+                                self.panier.draw(self.screen)
+                                for b in self.ball_list:
+                                    b.draw(self.screen)
+                                pygame.display.flip()
+                                self.clock.tick(60)
+
+                    ball.draw(self.screen)
+            # On ne conserve que les balles encore actives (pas rentrées ni hors écran)
+            self.ball_list = [b for b in self.ball_list if b.active]
+
+
+
+            # --- Mode challenge : repositionnement du panier et apparition de bonus ---
+            # En mode challenge, le panier se repositionne automatiquement toutes les 2 secondes,
+            # et un bonus apparaît toutes les 5 secondes à l'écran.
+            if self.challenge_mode:
+                if time.time() - self.challenge_timer > 2:
+                    self.panier.repositionner()
+                    self.challenge_timer = time.time()
+
+                if time.time() - self.last_bonus_spawn > 5:
+                    bonus = BonusItem("assets/image/bonus.png", SCREEN_WIDTH)
+                    self.bonus_items.append(bonus)
+                    self.last_bonus_spawn = time.time()
+
+
+
+            # --- Système de bonus : gestion des collisions et suppression ---
+            # Affiche les bonus, vérifie si le joueur les ramasse (collision), et les retire du jeu si besoin.
+            # Si le joueur ramasse un bonus, il gagne du temps supplémentaire.
+            for bonus in self.bonus_items:
+                bonus.update()
+                bonus.draw(self.screen)
+
+                if self.player.rect.colliderect(bonus.rect):
+                    self.start_time += TEMPS_ADDITIONNEL  # Ajoute du temps si bonus ramassé
+                    self.bonus_items.remove(bonus)
+
+            # Supprime les bonus qui sont sortis de l'écran
+            self.bonus_items = [b for b in self.bonus_items if not b.is_off_screen(SCREEN_HEIGHT)]
+
+
+            # Affichage du score, record, total
+            self.screen.blit(self.menu.font.render(f"Score: {self.score}", True, TEXT_COLOR), (20, 20))
+            record = self.score_manager.load_high_score()
+            self.screen.blit(self.menu.font.render(f"Record: {record}", True, TEXT_COLOR), (20, 50))
+            self.screen.blit(self.menu.font.render(f"Total: {self.total_score + self.score}", True, TEXT_COLOR),(20, 80))
+
+
+            if not self.challenge_mode:
+                objectif_text = self.menu.font.render(f"Objectif: 12", True, 'red')
+                self.screen.blit(objectif_text, objectif_text.get_rect(center=(SCREEN_WIDTH // 2, 50)))
+
+            pygame.display.flip()
+            self.clock.tick(60)
+
+        pygame.quit()
+
+    def reset_game(self):
+        """
+        Réinitialise l'état du jeu pour recommencer une partie.
+        """
+        self.ball_list = []
+        self.score = 0
+        self.start_time = time.time()
+        self.dragging = False
+        self.start_pos = None
+        self.game_started = True
+        self.game_over = False
+        self.challenge_mode = False
+        self.total_score = 0
+        self.bonus_items = []
+
+
+if __name__ == "__main__":
+    game = Game()
+    game.run()
Index: hungry_goals/engine/music_manager.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/engine/music_manager.py b/hungry_goals/engine/music_manager.py
new file mode 100644
--- /dev/null	(date 1747056376637)
+++ b/hungry_goals/engine/music_manager.py	(date 1747056376637)
@@ -0,0 +1,27 @@
+import pygame
+import os
+
+class MusicManager:
+    def __init__(self, path, volume=0.5):
+        pygame.mixer.init()
+        if os.path.exists(path):
+            pygame.mixer.music.load(path)
+            pygame.mixer.music.set_volume(volume)
+        else:
+            print(f"[ERREUR] Fichier introuvable : {path}")
+
+    def play(self, loop=True):
+        # Joue la musique en boucle si loop est True (avec -1), sinon la joue une seule fois (avec 0)
+        pygame.mixer.music.play(-1 if loop else 0)
+
+    def pause(self):
+        pygame.mixer.music.pause()
+
+    def resume(self):
+        pygame.mixer.music.unpause()
+
+    def stop(self):
+        pygame.mixer.music.stop()
+
+    def set_volume(self, value):
+        pygame.mixer.music.set_volume(value)
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"3f9c94da-8ffd-49b0-ad99-2d5c8ba20d2b\" name=\"Changes\" comment=\"equation de la balle a faire\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_04_05_2025_15_56_[Changes]1/shelved.patch\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/ui/README.md\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/ui/README.md\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Unit Test\" />\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;Adn1n&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">{\r\n  &quot;selectedUrlAndAccountId&quot;: {\r\n    &quot;url&quot;: &quot;https://github.com/Adn1n/Projet.git&quot;,\r\n    &quot;accountId&quot;: &quot;7b8e1e96-33d3-4b74-bdbd-fed687c054de&quot;\r\n  }\r\n}</component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 7\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2uR7N5TcrJvbazUTYd2KcelFrsp\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\">\r\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\r\n  </component>\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Python.arrow.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.ball.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.config.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.ds.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.entrainement.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.fonctions_utiles.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.game.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.joueur.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.main (1).executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.main.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.menu_screen.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.player.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.training.executor&quot;: &quot;Run&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;main&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;/Users/adnan/PycharmProjects/Projet_jeu_animation/assets/image/player_assets&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;inlay.hints&quot;,\r\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyFile.RECENT_KEYS\">\r\n      <recent name=\"$PROJECT_DIR$/assets/image/player_assets\" />\r\n      <recent name=\"$PROJECT_DIR$/image\" />\r\n      <recent name=\"$PROJECT_DIR$\" />\r\n    </key>\r\n    <key name=\"MoveFile.RECENT_KEYS\">\r\n      <recent name=\"$PROJECT_DIR$/src/entities\" />\r\n      <recent name=\"$PROJECT_DIR$/assets/image\" />\r\n      <recent name=\"$PROJECT_DIR$/assets\" />\r\n      <recent name=\"$PROJECT_DIR$/src/utils\" />\r\n      <recent name=\"$PROJECT_DIR$/src/scenes\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Python.game\">\r\n    <configuration name=\"game\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"Projet\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/src/core\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/src/core/game.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"main (1)\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"Projet\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$/src\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/src/main.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"main\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"Projet\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <EXTENSION ID=\"PythonCoverageRunConfigurationExtension\" runner=\"coverage.py\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/src/core/main.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.game\" />\r\n        <item itemvalue=\"Python.main (1)\" />\r\n        <item itemvalue=\"Python.main\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-js-predefined-d6986cc7102b-e768b9ed790e-JavaScript-PY-243.21565.199\" />\r\n        <option value=\"bundled-python-sdk-cab1f2013843-4ae2d6a61b08-com.jetbrains.pycharm.pro.sharedIndexes.bundled-PY-243.21565.199\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"3f9c94da-8ffd-49b0-ad99-2d5c8ba20d2b\" name=\"Changes\" comment=\"\" />\r\n      <created>1742199489440</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1742199489440</updated>\r\n      <workItem from=\"1742199491334\" duration=\"765000\" />\r\n      <workItem from=\"1742200272116\" duration=\"2820000\" />\r\n      <workItem from=\"1742482963738\" duration=\"44000\" />\r\n      <workItem from=\"1742484249828\" duration=\"370000\" />\r\n      <workItem from=\"1742484639993\" duration=\"9842000\" />\r\n      <workItem from=\"1742660955517\" duration=\"37000\" />\r\n      <workItem from=\"1742661013444\" duration=\"34652000\" />\r\n      <workItem from=\"1744621758817\" duration=\"220000\" />\r\n      <workItem from=\"1744629521929\" duration=\"12992000\" />\r\n      <workItem from=\"1744827803404\" duration=\"29542000\" />\r\n      <workItem from=\"1745280883966\" duration=\"298000\" />\r\n      <workItem from=\"1745363706501\" duration=\"65000\" />\r\n      <workItem from=\"1745427382739\" duration=\"175000\" />\r\n      <workItem from=\"1745427682927\" duration=\"2142000\" />\r\n      <workItem from=\"1745935730041\" duration=\"1647000\" />\r\n      <workItem from=\"1746013292880\" duration=\"4621000\" />\r\n      <workItem from=\"1746028827658\" duration=\"6189000\" />\r\n      <workItem from=\"1746164656512\" duration=\"17804000\" />\r\n      <workItem from=\"1746219717802\" duration=\"7299000\" />\r\n      <workItem from=\"1746472035167\" duration=\"311000\" />\r\n      <workItem from=\"1746472362332\" duration=\"67000\" />\r\n      <workItem from=\"1746474358695\" duration=\"2141000\" />\r\n      <workItem from=\"1746628892495\" duration=\"1032000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Teddy\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742199860531</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742199860531</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Teddy\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742200582452</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742200582452</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"Teddy\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742200630355</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742200630355</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"Teddy\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742200996335</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742200996335</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"Teddy\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742201347579</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742201347579</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"Teddy\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742484924438</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742484924438</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"Du nouveau\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742745693735</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742745693735</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"Du nouveau\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742745721134</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742745721134</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"Du nouveau\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742813020627</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742813020627</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00010\" summary=\"Du nouveau\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742815888119</created>\r\n      <option name=\"number\" value=\"00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742815888119</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00011\" summary=\"Du nouveau\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742816384940</created>\r\n      <option name=\"number\" value=\"00011\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742816384940</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00012\" summary=\"Il manque juste la partie de la fleche a finir\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1744638930121</created>\r\n      <option name=\"number\" value=\"00012\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1744638930121</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00013\" summary=\"Fleche coder XXX il reste la balle a faire\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1744755753778</created>\r\n      <option name=\"number\" value=\"00013\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1744755753778</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00014\" summary=\"Reste a coder la balle et j'ai bien definis la les espaces de tirs\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1744841080257</created>\r\n      <option name=\"number\" value=\"00014\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1744841080257</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00015\" summary=\"Reorganisation et commentaire de chaque fichier\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1745065780874</created>\r\n      <option name=\"number\" value=\"00015\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1745065780874</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00016\" summary=\"Ball coder mais il reste a mettre a jour ces equation apres chaque spawn\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1745075277484</created>\r\n      <option name=\"number\" value=\"00016\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1745075277484</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00017\" summary=\"class Ball:&#10;    def __init__(self):&#10;        self.vy = 0&#10;        self.gravity = 8&#10;&#10;    def update(self):&#10;        self.vy += self.gravity&#10;        print(&quot;gravité appliquée&quot;, self.vy)&#10;&#10;        # Corrige les blocages de la vitesse en tenant compte de la direction&#10;        if abs(self.vy) &lt; 0.1 and self.vy &gt; 0:&#10;            self.vy = 0&#10;&#10;        # Arrêt automatique si la balle est presque immobile&#10;        if abs(self.vy) &lt; 0.05 and abs(self.vx) &lt; 0.05:&#10;            self.vy = 0&#10;            self.vx = 0&#10;            self.tir = False\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1745185153701</created>\r\n      <option name=\"number\" value=\"00017\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1745185153701</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00018\" summary=\"read me\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1745438726124</created>\r\n      <option name=\"number\" value=\"00018\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00018\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1745438726124</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00019\" summary=\"equation de la balle a faire\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1746110206251</created>\r\n      <option name=\"number\" value=\"00019\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00019\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1746110206251</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00020\" summary=\"equation de la balle a faire\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1746472069869</created>\r\n      <option name=\"number\" value=\"00020\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00020\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1746472069869</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"21\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"Teddy\" />\r\n    <MESSAGE value=\"Du nouveau\" />\r\n    <MESSAGE value=\"Il manque juste la partie de la fleche a finir\" />\r\n    <MESSAGE value=\"Fleche coder XXX il reste la balle a faire\" />\r\n    <MESSAGE value=\"Reste a coder la balle et j'ai bien definis la les espaces de tirs\" />\r\n    <MESSAGE value=\"Reorganisation et commentaire de chaque fichier\" />\r\n    <MESSAGE value=\"Ball coder mais il reste a mettre a jour ces equation apres chaque spawn\" />\r\n    <MESSAGE value=\"class Ball:&#10;    def __init__(self):&#10;        self.vy = 0&#10;        self.gravity = 8&#10;&#10;    def update(self):&#10;        self.vy += self.gravity&#10;        print(&quot;gravité appliquée&quot;, self.vy)&#10;&#10;        # Corrige les blocages de la vitesse en tenant compte de la direction&#10;        if abs(self.vy) &lt; 0.1 and self.vy &gt; 0:&#10;            self.vy = 0&#10;&#10;        # Arrêt automatique si la balle est presque immobile&#10;        if abs(self.vy) &lt; 0.05 and abs(self.vx) &lt; 0.05:&#10;            self.vy = 0&#10;            self.vx = 0&#10;            self.tir = False\" />\r\n    <MESSAGE value=\"read me\" />\r\n    <MESSAGE value=\"equation de la balle a faire\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"equation de la balle a faire\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/src/core/config.py</url>\r\n          <option name=\"timeStamp\" value=\"1\" />\r\n        </line-breakpoint>\r\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/src/core/fenetre.py</url>\r\n          <option name=\"timeStamp\" value=\"2\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\r\n    <SUITE FILE_PATH=\"coverage/Projet_jeu_animation$entrainement.coverage\" NAME=\"entrainement Coverage Results\" MODIFIED=\"1744630161112\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet_jeu_animation$game.coverage\" NAME=\"game Coverage Results\" MODIFIED=\"1744631392449\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet$game.coverage\" NAME=\"game Coverage Results\" MODIFIED=\"1746921376223\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/src/core\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet$joueur.coverage\" NAME=\"joueur Coverage Results\" MODIFIED=\"1742748867964\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet_jeu_animation$ds.coverage\" NAME=\"ds Coverage Results\" MODIFIED=\"1746214596926\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/src/core\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet$fonctions_utiles.coverage\" NAME=\"fonctions_utiles Coverage Results\" MODIFIED=\"1744007724164\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet_jeu_animation$ball.coverage\" NAME=\"ball Coverage Results\" MODIFIED=\"1746212315037\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/src/entities\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet_jeu_animation$player.coverage\" NAME=\"player Coverage Results\" MODIFIED=\"1744636781451\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet$menu_screen.coverage\" NAME=\"menu_screen Coverage Results\" MODIFIED=\"1742762950347\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet$entrainement.coverage\" NAME=\"entrainement Coverage Results\" MODIFIED=\"1742741010630\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet_jeu_animation$arrow.coverage\" NAME=\"arrow Coverage Results\" MODIFIED=\"1744655204824\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet$player.coverage\" NAME=\"player Coverage Results\" MODIFIED=\"1742662578953\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet$main__1_.coverage\" NAME=\"main (1) Coverage Results\" MODIFIED=\"1746475164032\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$/src\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet_jeu_animation$training.coverage\" NAME=\"training Coverage Results\" MODIFIED=\"1744655003443\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet_jeu_animation$main.coverage\" NAME=\"main Coverage Results\" MODIFIED=\"1744755669401\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet$config.coverage\" NAME=\"config Coverage Results\" MODIFIED=\"1742817056757\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Projet$main.coverage\" NAME=\"main Coverage Results\" MODIFIED=\"1746627685837\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 1f8a1232f33d91701da6d3083fc3b78f1a430e7b)
+++ b/.idea/workspace.xml	(date 1747056506504)
@@ -4,10 +4,21 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
+<<<<<<< HEAD
     <list default="true" id="3f9c94da-8ffd-49b0-ad99-2d5c8ba20d2b" name="Changes" comment="equation de la balle a faire">
       <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_04_05_2025_15_56_[Changes]1/shelved.patch" beforeDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/ui/README.md" beforeDir="false" afterPath="$PROJECT_DIR$/src/ui/README.md" afterDir="false" />
+=======
+    <list default="true" id="3f9c94da-8ffd-49b0-ad99-2d5c8ba20d2b" name="Changes" comment="Tout carre normalement">
+      <change beforePath="$PROJECT_DIR$/.idea/Projet.iml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/Projet.iml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_04_05_2025_15_56_[Changes]1/shelved.patch" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_04_05_2025_15_56__Changes_1.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/high_scores.txt" beforeDir="false" afterPath="$PROJECT_DIR$/high_scores.txt" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/hungry_goals/engine/game.py" beforeDir="false" afterPath="$PROJECT_DIR$/hungry_goals/engine/game.py" afterDir="false" />
+>>>>>>> 6712d678f229273520f0b999c578b5062fdc76be
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -34,7 +45,11 @@
   <component name="GithubPullRequestsUISettings">{
   &quot;selectedUrlAndAccountId&quot;: {
     &quot;url&quot;: &quot;https://github.com/Adn1n/Projet.git&quot;,
+<<<<<<< HEAD
     &quot;accountId&quot;: &quot;7b8e1e96-33d3-4b74-bdbd-fed687c054de&quot;
+=======
+    &quot;accountId&quot;: &quot;1d4673ab-fdd8-462b-a347-4212ad4de6ce&quot;
+>>>>>>> 6712d678f229273520f0b999c578b5062fdc76be
   }
 }</component>
   <component name="ProjectColorInfo">{
@@ -59,6 +74,7 @@
     &quot;Python.game.executor&quot;: &quot;Run&quot;,
     &quot;Python.joueur.executor&quot;: &quot;Run&quot;,
     &quot;Python.main (1).executor&quot;: &quot;Run&quot;,
+    &quot;Python.main (2).executor&quot;: &quot;Run&quot;,
     &quot;Python.main.executor&quot;: &quot;Run&quot;,
     &quot;Python.menu_screen.executor&quot;: &quot;Run&quot;,
     &quot;Python.player.executor&quot;: &quot;Run&quot;,
@@ -66,7 +82,7 @@
     &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
     &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,
     &quot;git-widget-placeholder&quot;: &quot;main&quot;,
-    &quot;last_opened_file_path&quot;: &quot;/Users/adnan/PycharmProjects/Projet_jeu_animation/assets/image/player_assets&quot;,
+    &quot;last_opened_file_path&quot;: &quot;/Users/adnan/PycharmProjects/Projet/assets/sounds&quot;,
     &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
     &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
     &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
@@ -78,6 +94,7 @@
 }</component>
   <component name="RecentsManager">
     <key name="CopyFile.RECENT_KEYS">
+      <recent name="$PROJECT_DIR$/assets/sounds" />
       <recent name="$PROJECT_DIR$/assets/image/player_assets" />
       <recent name="$PROJECT_DIR$/image" />
       <recent name="$PROJECT_DIR$" />
@@ -90,8 +107,8 @@
       <recent name="$PROJECT_DIR$/src/scenes" />
     </key>
   </component>
-  <component name="RunManager" selected="Python.game">
-    <configuration name="game" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+  <component name="RunManager">
+    <configuration name="main" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
       <module name="Projet" />
       <option name="ENV_FILES" value="" />
       <option name="INTERPRETER_OPTIONS" value="" />
@@ -100,35 +117,12 @@
         <env name="PYTHONUNBUFFERED" value="1" />
       </envs>
       <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/src/core" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
       <option name="IS_MODULE_SDK" value="true" />
       <option name="ADD_CONTENT_ROOTS" value="true" />
       <option name="ADD_SOURCE_ROOTS" value="true" />
       <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
-      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/src/core/game.py" />
-      <option name="PARAMETERS" value="" />
-      <option name="SHOW_COMMAND_LINE" value="false" />
-      <option name="EMULATE_TERMINAL" value="false" />
-      <option name="MODULE_MODE" value="false" />
-      <option name="REDIRECT_INPUT" value="false" />
-      <option name="INPUT_FILE" value="" />
-      <method v="2" />
-    </configuration>
-    <configuration name="main (1)" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
-      <module name="Projet" />
-      <option name="ENV_FILES" value="" />
-      <option name="INTERPRETER_OPTIONS" value="" />
-      <option name="PARENT_ENVS" value="true" />
-      <envs>
-        <env name="PYTHONUNBUFFERED" value="1" />
-      </envs>
-      <option name="SDK_HOME" value="" />
-      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/src" />
-      <option name="IS_MODULE_SDK" value="true" />
-      <option name="ADD_CONTENT_ROOTS" value="true" />
-      <option name="ADD_SOURCE_ROOTS" value="true" />
-      <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
-      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/src/main.py" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/hungry_goals/main.py" />
       <option name="PARAMETERS" value="" />
       <option name="SHOW_COMMAND_LINE" value="false" />
       <option name="EMULATE_TERMINAL" value="false" />
@@ -162,8 +156,7 @@
     </configuration>
     <recent_temporary>
       <list>
-        <item itemvalue="Python.game" />
-        <item itemvalue="Python.main (1)" />
+        <item itemvalue="Python.main" />
         <item itemvalue="Python.main" />
       </list>
     </recent_temporary>
@@ -171,8 +164,8 @@
   <component name="SharedIndexes">
     <attachedChunks>
       <set>
-        <option value="bundled-js-predefined-d6986cc7102b-e768b9ed790e-JavaScript-PY-243.21565.199" />
-        <option value="bundled-python-sdk-cab1f2013843-4ae2d6a61b08-com.jetbrains.pycharm.pro.sharedIndexes.bundled-PY-243.21565.199" />
+        <option value="bundled-js-predefined-d6986cc7102b-1632447f56bf-JavaScript-PY-243.26053.29" />
+        <option value="bundled-python-sdk-b1dbf8ef85a6-4df51de95216-com.jetbrains.pycharm.pro.sharedIndexes.bundled-PY-243.26053.29" />
       </set>
     </attachedChunks>
   </component>
@@ -207,6 +200,9 @@
       <workItem from="1746472362332" duration="67000" />
       <workItem from="1746474358695" duration="2141000" />
       <workItem from="1746628892495" duration="1032000" />
+      <workItem from="1746919192474" duration="3035000" />
+      <workItem from="1746998521474" duration="2244000" />
+      <workItem from="1747038711170" duration="2256000" />
     </task>
     <task id="LOCAL-00001" summary="Teddy">
       <option name="closed" value="true" />
@@ -368,7 +364,87 @@
       <option name="project" value="LOCAL" />
       <updated>1746472069869</updated>
     </task>
-    <option name="localTasksCounter" value="21" />
+    <task id="LOCAL-00021" summary="code_omar_update">
+      <option name="closed" value="true" />
+      <created>1746919237518</created>
+      <option name="number" value="00021" />
+      <option name="presentableId" value="LOCAL-00021" />
+      <option name="project" value="LOCAL" />
+      <updated>1746919237518</updated>
+    </task>
+    <task id="LOCAL-00022" summary="code_omar_update">
+      <option name="closed" value="true" />
+      <created>1746960529853</created>
+      <option name="number" value="00022" />
+      <option name="presentableId" value="LOCAL-00022" />
+      <option name="project" value="LOCAL" />
+      <updated>1746960529853</updated>
+    </task>
+    <task id="LOCAL-00023" summary="code_omar_update">
+      <option name="closed" value="true" />
+      <created>1746962554787</created>
+      <option name="number" value="00023" />
+      <option name="presentableId" value="LOCAL-00023" />
+      <option name="project" value="LOCAL" />
+      <updated>1746962554787</updated>
+    </task>
+    <task id="LOCAL-00024" summary="Soignneeeee">
+      <option name="closed" value="true" />
+      <created>1746970068167</created>
+      <option name="number" value="00024" />
+      <option name="presentableId" value="LOCAL-00024" />
+      <option name="project" value="LOCAL" />
+      <updated>1746970068167</updated>
+    </task>
+    <task id="LOCAL-00025" summary="Commenté">
+      <option name="closed" value="true" />
+      <created>1746974954199</created>
+      <option name="number" value="00025" />
+      <option name="presentableId" value="LOCAL-00025" />
+      <option name="project" value="LOCAL" />
+      <updated>1746974954199</updated>
+    </task>
+    <task id="LOCAL-00026" summary="Tout carre normalement">
+      <option name="closed" value="true" />
+      <created>1746977058155</created>
+      <option name="number" value="00026" />
+      <option name="presentableId" value="LOCAL-00026" />
+      <option name="project" value="LOCAL" />
+      <updated>1746977058155</updated>
+    </task>
+    <task id="LOCAL-00027" summary="Tout carre normalement">
+      <option name="closed" value="true" />
+      <created>1746979762294</created>
+      <option name="number" value="00027" />
+      <option name="presentableId" value="LOCAL-00027" />
+      <option name="project" value="LOCAL" />
+      <updated>1746979762294</updated>
+    </task>
+    <task id="LOCAL-00028" summary="Tout carre normalement">
+      <option name="closed" value="true" />
+      <created>1746988627089</created>
+      <option name="number" value="00028" />
+      <option name="presentableId" value="LOCAL-00028" />
+      <option name="project" value="LOCAL" />
+      <updated>1746988627089</updated>
+    </task>
+    <task id="LOCAL-00029" summary="Tout carre normalement">
+      <option name="closed" value="true" />
+      <created>1746989130504</created>
+      <option name="number" value="00029" />
+      <option name="presentableId" value="LOCAL-00029" />
+      <option name="project" value="LOCAL" />
+      <updated>1746989130504</updated>
+    </task>
+    <task id="LOCAL-00030" summary="Tout carre normalement">
+      <option name="closed" value="true" />
+      <created>1746995794754</created>
+      <option name="number" value="00030" />
+      <option name="presentableId" value="LOCAL-00030" />
+      <option name="project" value="LOCAL" />
+      <updated>1746995794754</updated>
+    </task>
+    <option name="localTasksCounter" value="31" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -396,7 +472,11 @@
     <MESSAGE value="class Ball:&#10;    def __init__(self):&#10;        self.vy = 0&#10;        self.gravity = 8&#10;&#10;    def update(self):&#10;        self.vy += self.gravity&#10;        print(&quot;gravité appliquée&quot;, self.vy)&#10;&#10;        # Corrige les blocages de la vitesse en tenant compte de la direction&#10;        if abs(self.vy) &lt; 0.1 and self.vy &gt; 0:&#10;            self.vy = 0&#10;&#10;        # Arrêt automatique si la balle est presque immobile&#10;        if abs(self.vy) &lt; 0.05 and abs(self.vx) &lt; 0.05:&#10;            self.vy = 0&#10;            self.vx = 0&#10;            self.tir = False" />
     <MESSAGE value="read me" />
     <MESSAGE value="equation de la balle a faire" />
-    <option name="LAST_COMMIT_MESSAGE" value="equation de la balle a faire" />
+    <MESSAGE value="code_omar_update" />
+    <MESSAGE value="Soignneeeee" />
+    <MESSAGE value="Commenté" />
+    <MESSAGE value="Tout carre normalement" />
+    <option name="LAST_COMMIT_MESSAGE" value="Tout carre normalement" />
   </component>
   <component name="XDebuggerManager">
     <breakpoint-manager>
@@ -414,21 +494,28 @@
   </component>
   <component name="com.intellij.coverage.CoverageDataManagerImpl">
     <SUITE FILE_PATH="coverage/Projet_jeu_animation$entrainement.coverage" NAME="entrainement Coverage Results" MODIFIED="1744630161112" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+<<<<<<< HEAD
     <SUITE FILE_PATH="coverage/Projet_jeu_animation$game.coverage" NAME="game Coverage Results" MODIFIED="1744631392449" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/Projet$game.coverage" NAME="game Coverage Results" MODIFIED="1746921376223" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/src/core" />
     <SUITE FILE_PATH="coverage/Projet$joueur.coverage" NAME="joueur Coverage Results" MODIFIED="1742748867964" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+=======
+>>>>>>> 6712d678f229273520f0b999c578b5062fdc76be
     <SUITE FILE_PATH="coverage/Projet_jeu_animation$ds.coverage" NAME="ds Coverage Results" MODIFIED="1746214596926" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/src/core" />
-    <SUITE FILE_PATH="coverage/Projet$fonctions_utiles.coverage" NAME="fonctions_utiles Coverage Results" MODIFIED="1744007724164" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/Projet_jeu_animation$training.coverage" NAME="training Coverage Results" MODIFIED="1744655003443" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/Projet$main__1_.coverage" NAME="main (1) Coverage Results" MODIFIED="1746475164032" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/src" />
+    <SUITE FILE_PATH="coverage/Projet_jeu_animation$arrow.coverage" NAME="arrow Coverage Results" MODIFIED="1744655204824" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/Projet$player.coverage" NAME="player Coverage Results" MODIFIED="1742662578953" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/Projet$game.coverage" NAME="game Coverage Results" MODIFIED="1746965801695" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/src/core" />
+    <SUITE FILE_PATH="coverage/Projet$main.coverage" NAME="main Coverage Results" MODIFIED="1747041423818" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/Projet_jeu_animation$ball.coverage" NAME="ball Coverage Results" MODIFIED="1746212315037" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/src/entities" />
+    <SUITE FILE_PATH="coverage/Projet_jeu_animation$game.coverage" NAME="game Coverage Results" MODIFIED="1744631392449" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/Projet$entrainement.coverage" NAME="entrainement Coverage Results" MODIFIED="1742741010630" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/Projet$joueur.coverage" NAME="joueur Coverage Results" MODIFIED="1742748867964" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/Projet_jeu_animation$player.coverage" NAME="player Coverage Results" MODIFIED="1744636781451" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/Projet$fonctions_utiles.coverage" NAME="fonctions_utiles Coverage Results" MODIFIED="1744007724164" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/Projet$menu_screen.coverage" NAME="menu_screen Coverage Results" MODIFIED="1742762950347" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
-    <SUITE FILE_PATH="coverage/Projet$entrainement.coverage" NAME="entrainement Coverage Results" MODIFIED="1742741010630" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
-    <SUITE FILE_PATH="coverage/Projet_jeu_animation$arrow.coverage" NAME="arrow Coverage Results" MODIFIED="1744655204824" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
-    <SUITE FILE_PATH="coverage/Projet$player.coverage" NAME="player Coverage Results" MODIFIED="1742662578953" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
-    <SUITE FILE_PATH="coverage/Projet$main__1_.coverage" NAME="main (1) Coverage Results" MODIFIED="1746475164032" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/src" />
-    <SUITE FILE_PATH="coverage/Projet_jeu_animation$training.coverage" NAME="training Coverage Results" MODIFIED="1744655003443" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/Projet_jeu_animation$main.coverage" NAME="main Coverage Results" MODIFIED="1744755669401" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/Projet$config.coverage" NAME="config Coverage Results" MODIFIED="1742817056757" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
-    <SUITE FILE_PATH="coverage/Projet$main.coverage" NAME="main Coverage Results" MODIFIED="1746627685837" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/Projet$main__2_.coverage" NAME="main (2) Coverage Results" MODIFIED="1746965793847" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/code_omar" />
   </component>
 </project>
\ No newline at end of file
Index: hungry_goals/engine/score_manager.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/engine/score_manager.py b/hungry_goals/engine/score_manager.py
new file mode 100644
--- /dev/null	(date 1747056376637)
+++ b/hungry_goals/engine/score_manager.py	(date 1747056376637)
@@ -0,0 +1,17 @@
+import os
+
+class ScoreManager:
+    def __init__(self, path="high_scores.txt"):
+        self.path = path
+
+    # Lit le fichier de score s’il existe, et retourne 0 si le fichier est vide ou absent.
+    def load_high_score(self):
+        if not os.path.exists(self.path):
+            return 0
+        with open(self.path, "r") as f:
+            line = f.readline().strip()
+            return int(line) if line.isdigit() else 0
+
+    def save_high_score(self, score):
+        with open(self.path, "w") as f:
+            f.write(f"{score}\n")
\ No newline at end of file
Index: hungry_goals/engine/window.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/engine/window.py b/hungry_goals/engine/window.py
new file mode 100644
--- /dev/null	(date 1747056376638)
+++ b/hungry_goals/engine/window.py	(date 1747056376638)
@@ -0,0 +1,39 @@
+import pygame
+from hungry_goals.engine.config import SCREEN_WIDTH, SCREEN_HEIGHT
+# Classe Fenetre : gère la fenêtre principale du jeu avec Pygame.
+class Fenetre:
+    def __init__(self, title="My Game", resizable=True):
+        """
+        Initialise la fenêtre du jeu.
+        - title : le titre affiché dans la barre de la fenêtre.
+        - resizable : permet de redimensionner la fenêtre si True.
+        """
+        # Détermine le drapeau pour rendre la fenêtre redimensionnable si demandé.
+        flags = pygame.RESIZABLE if resizable else 0
+
+        # Crée la fenêtre principale avec la largeur et hauteur définies dans la config.
+        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), flags)
+
+        # Définit le titre de la fenêtre.
+        pygame.display.set_caption(title)
+
+    def get_screen(self):
+        """
+        Retourne la surface (screen) sur laquelle dessiner.
+        Utile pour accéder à la fenêtre depuis d'autres classes.
+        """
+        return self.screen
+
+    def clear(self, color):
+        """
+        Efface la fenêtre en la remplissant avec une couleur (tuple RGB).
+        À appeler au début de chaque frame pour réinitialiser l'affichage.
+        """
+        self.screen.fill(color)
+
+    def update(self):
+        """
+        Met à jour l'affichage de la fenêtre.
+        À appeler à la fin de chaque frame pour afficher les dessins à l'écran.
+        """
+        pygame.display.flip()
\ No newline at end of file
Index: hungry_goals/entities/arrow.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/entities/arrow.py b/hungry_goals/entities/arrow.py
new file mode 100644
--- /dev/null	(date 1747056376638)
+++ b/hungry_goals/entities/arrow.py	(date 1747056376638)
@@ -0,0 +1,76 @@
+import pygame
+import math
+
+from hungry_goals.engine.config import *
+
+# Classe Arrow : gère la simulation et l'affichage de la trajectoire d'une flèche (ou balle)
+# en tenant compte de la gravité et des rebonds sur les bords de la fenêtre.
+class Arrow:
+    def __init__(self, gravity=0.5, color=(0, 0, 0)):
+        """
+        Constructeur de la classe Arrow.
+        :param gravity: Accélération due à la gravité appliquée à chaque étape (float).
+        :param color: Couleur principale de la flèche (tuple RGB), utilisée pour d'autres dessins éventuels.
+        Attributs :
+            self.gravity : gravité appliquée à la trajectoire.
+            self.color : couleur de la flèche.
+        """
+        self.gravity = gravity
+        self.color = color
+
+    def draw_trajectory(self, surface, start_pos, angle, power, steps=40):
+        """
+        Dessine la trajectoire prédite de la flèche en tenant compte de la gravité et des rebonds.
+        :param surface: Surface pygame sur laquelle dessiner.
+        :param start_pos: Tuple (x, y) indiquant la position initiale de la flèche.
+        :param angle: Angle de tir en radians.
+        :param power: Puissance du tir (vitesse initiale).
+        :param steps: Nombre d'étapes de simulation pour la trajectoire.
+        """
+        # Initialisation de la position de départ (convertie en float pour la précision)
+        x = float(start_pos[0])
+        y = float(start_pos[1])
+        # Calcul des composantes de la vitesse initiale selon l'angle et la puissance
+        vel_x = math.cos(angle) * power
+        vel_y = math.sin(angle) * power
+        # Rayon de la balle (importé depuis la config)
+        radius = BALL_RADIUS  # doit être importé depuis config
+
+        for i in range(steps):
+            # Temps simulé (le pas peut être ajusté pour raffiner l'affichage)
+            t = i * 0.5  # par exemple 0.5 secondes entre chaque point
+
+            # Formules explicites basées sur les équations du mouvement parabolique
+            x = start_pos[0] + math.cos(angle) * power * t
+            y = start_pos[1] + math.sin(angle) * power * t + 0.5 * self.gravity * t ** 2
+
+            # Vérifie si la position est encore dans la fenêtre, sinon on arrête la simulation
+            if 0 <= x <= surface.get_width() and 0 <= y <= surface.get_height():
+                # Dessine un cercle pour représenter la position de la flèche à cette étape
+                pygame.draw.circle(surface, (200, 0, 200), (int(x), int(y)), 4)
+            else:
+                break
+
+            # Application de la gravité à la vitesse verticale
+            vel_y += self.gravity
+
+            # Gestion du rebond contre le sol (bord inférieur)
+            if y + radius >= surface.get_height():
+                # Replace la balle juste au-dessus du sol pour éviter de passer au travers
+                y = surface.get_height() - radius
+                # Si la vitesse verticale est suffisante, rebondit avec perte d'énergie
+                if abs(vel_y) > 1:
+                    vel_y *= -0.5   # Inverse et réduit la vitesse verticale (rebond amorti)
+                    vel_x *= 0.95   # Amortit aussi la vitesse horizontale pour simuler le frottement
+                else:
+                    # Si la vitesse est trop faible, on arrête la simulation (la balle "s'arrête")
+                    break
+
+            # Gestion du rebond contre le mur gauche
+            if x - radius <= 0:
+                x = radius  # Replace la balle juste à l'intérieur du mur
+                vel_x *= -0.8  # Inverse et réduit la vitesse horizontale (rebond amorti)
+            # Gestion du rebond contre le mur droit
+            elif x + radius >= surface.get_width():
+                x = surface.get_width() - radius
+                vel_x *= -0.8
\ No newline at end of file
Index: hungry_goals/entities/ball.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/entities/ball.py b/hungry_goals/entities/ball.py
new file mode 100644
--- /dev/null	(date 1747056376639)
+++ b/hungry_goals/entities/ball.py	(date 1747056376639)
@@ -0,0 +1,155 @@
+import os
+import pygame
+import math
+import time
+
+from hungry_goals.engine.config import *
+#
+
+class Ball:
+    """
+    Classe représentant une balle de basket.
+    Gère la position, la vitesse, les collisions, le rendu et l'état de la balle.
+    """
+
+    def __init__(self, x, y, angle, power):
+        """
+        Initialise une balle avec une position, une vitesse initiale basée sur un angle et une puissance,
+        et charge l'image associée.
+
+        :param x: Position initiale en x
+        :param y: Position initiale en y
+        :param angle: Angle de tir en radians
+        :param power: Puissance initiale du tir
+        """
+        # Position initiale de la balle
+        self.x = x
+        self.y = y
+
+        # Vitesse initiale calculée à partir de l'angle et de la puissance
+        self.vel_x = math.cos(angle) * power
+        self.vel_y = math.sin(angle) * power
+
+        # Indique si la balle est encore en mouvement ou active dans le jeu
+        self.active = True
+
+        # Temps auquel la balle s'est arrêtée (utilisé pour désactiver après un délai)
+        self.rest_time = None
+
+        # Indique si la balle a marqué un point
+        self.scored = False
+
+        # Construction du chemin vers l'image de la balle
+        base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+        image_path = os.path.join(base_path, "assets", "image", "Ball.png")
+
+        # Chargement et redimensionnement de l'image de la balle
+        self.ball_image = pygame.image.load(image_path)
+        self.ball_image = pygame.transform.scale(self.ball_image, (50, 50))  # Ajuste la taille pour correspondre à la balle originale
+
+        # Rayon de la balle, utilisé pour les calculs de collision
+        self.ball_radius = self.ball_image.get_width() // 2
+
+
+
+    def update(self, gravity, screen_height, backboard_rect, basket_rect, hoop_center_rect):
+        """
+        Met à jour la position et la vitesse de la balle en fonction de la gravité,
+        gère les rebonds sur les bords de l'écran et les collisions avec les éléments du panier.
+        Gère également les conditions de score et d'arrêt de la balle.
+
+        :param gravity: Force de gravité appliquée à la balle
+        :param screen_height: Hauteur de l'écran pour détecter le sol
+        :param backboard_rect: Rect du panneau arrière pour collision
+        :param basket_rect: Rect du panier pour collision
+        :param hoop_center_rect: Rect du centre du cerceau pour collision et score
+        :return: "score" si la balle marque un point, sinon None
+        """
+        if not self.active:
+            # Si la balle n'est plus active, on ne fait pas de mise à jour
+            return
+
+        # Application de la gravité sur la vitesse verticale
+        self.vel_y += gravity
+
+        # Mise à jour des positions selon les vitesses
+        self.x += self.vel_x
+        self.y += self.vel_y
+
+        # Gestion du rebond sur le sol (bas de l'écran)
+        if self.y + self.ball_radius >= screen_height:
+            self.y = screen_height - self.ball_radius  # Positionne la balle juste au sol
+            if abs(self.vel_y) > 1:
+                # Rebond amorti si la vitesse verticale est suffisante
+                self.vel_y *= -0.5
+                self.vel_x *= 0.95  # Perte légère de vitesse horizontale
+            else:
+                # Si la vitesse verticale est faible, la balle s'arrête
+                self.vel_y = 0
+                self.vel_x = 0
+                if self.rest_time is None:
+                    # Enregistre le temps d'arrêt pour désactivation ultérieure
+                    self.rest_time = time.time()
+
+        # Rebond sur le côté gauche de l'écran
+        if self.x - self.ball_radius <= 0:
+            self.x = self.ball_radius  # Positionne la balle au bord gauche
+            self.vel_x *= -0.8  # Rebond plus doux sur l'axe horizontal
+            self.vel_y *= 0.95  # Légère perte d’énergie verticale
+
+        # Rebond sur le côté droit de l'écran
+        elif self.x + self.ball_radius >= SCREEN_WIDTH:
+            self.x = SCREEN_WIDTH - self.ball_radius  # Positionne la balle au bord droit
+            self.vel_x *= -0.8  # Rebond plus doux sur l'axe horizontal
+            self.vel_y *= 0.95  # Légère perte d’énergie verticale
+
+        # Collision avec les bords extrêmes de l'écran (zones proches des limites)
+        if self.x - 10 <= 0 or self.x + 10 >= 1000:
+            self.vel_x *= -0.6  # Rebond plus amorti horizontalement
+
+        # Collision avec le panneau arrière du panier
+        if self.rect().colliderect(backboard_rect):
+            self.x -= self.vel_x  # Recule la balle pour éviter chevauchement
+            self.vel_x *= -0.7  # Rebond amorti sur l'axe horizontal
+
+        # Collision avec le panier (anneau)
+        if self.rect().colliderect(basket_rect):
+            self.x -= self.vel_x  # Recule la balle pour éviter chevauchement
+            self.vel_x *= -0.6  # Rebond amorti sur l'axe horizontal
+
+        # Détection de score : collision avec le centre du cerceau en descente et pas encore marqué
+        if self.rect().colliderect(hoop_center_rect) and self.vel_y > 0 and not self.scored:
+            self.active = False  # Désactive la balle car elle a marqué
+            self.scored = True
+            return "score"
+
+        # Si la balle touche le fond du cerceau venant d'en dessous, on la désactive sans marquer
+        if self.rect().colliderect(hoop_center_rect) and self.vel_y < 0:
+            self.active = False
+            return
+
+        # Désactivation de la balle après un certain temps d'arrêt sur le sol
+        if self.rest_time and time.time() - self.rest_time > 1.5:
+            self.active = False
+
+
+
+    def draw(self, screen):
+        """
+        Dessine la balle à l'écran en positionnant l'image centrée sur la position (x, y).
+
+        :param screen: Surface Pygame sur laquelle dessiner la balle
+        """
+        # Place l'image de la balle en ajustant pour que le centre corresponde à (self.x, self.y)
+        screen.blit(self.ball_image, (int(self.x - self.ball_radius), int(self.y - self.ball_radius)))
+
+
+
+    def rect(self):
+        """
+        Retourne un rectangle pygame correspondant à la zone occupée par la balle,
+        utilisé pour les détections de collision.
+
+        :return: pygame.Rect représentant la zone de la balle
+        """
+        return pygame.Rect(self.x - self.ball_radius, self.y - self.ball_radius, self.ball_radius * 2, self.ball_radius * 2)
\ No newline at end of file
Index: hungry_goals/entities/bonus_item.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/entities/bonus_item.py b/hungry_goals/entities/bonus_item.py
new file mode 100644
--- /dev/null	(date 1747056376640)
+++ b/hungry_goals/entities/bonus_item.py	(date 1747056376640)
@@ -0,0 +1,44 @@
+# Projet : Hungry Buckets
+# Description : Ce fichier définit la classe BonusItem, qui gère l’apparition, le mouvement et l’affichage des objets bonus dans le jeu.
+
+import pygame
+import random
+
+class BonusItem:
+    def __init__(self, image, screen_width):
+        """
+        Constructeur de la classe BonusItem.
+        :param image: chemin vers l'image de l'objet bonus.
+        :param screen_width: largeur de l'écran pour positionnement horizontal.
+        Ne retourne rien.
+        """
+        raw_img = pygame.image.load(image).convert_alpha()
+        self.image = pygame.transform.scale(raw_img, (48, 48))
+        self.rect = self.image.get_rect()
+        self.rect.x = random.randint(50, screen_width - 50)
+        self.rect.y = -self.rect.height
+        self.speed = 8
+
+    def update(self):
+        """
+        Met à jour la position verticale de l'objet bonus.
+        Ne prend pas de paramètre.
+        Ne retourne rien.
+        """
+        self.rect.y += self.speed
+
+    def draw(self, surface):
+        """
+        Dessine l'objet bonus sur la surface donnée.
+        :param surface: surface pygame sur laquelle dessiner l'objet.
+        Ne retourne rien.
+        """
+        surface.blit(self.image, self.rect.topleft)
+
+    def is_off_screen(self, screen_height):
+        """
+        Vérifie si l'objet bonus est sorti de l'écran.
+        :param screen_height: hauteur de l'écran.
+        :return: True si l'objet est hors écran, sinon False.
+        """
+        return self.rect.top > screen_height
\ No newline at end of file
Index: hungry_goals/entities/hoop.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/entities/hoop.py b/hungry_goals/entities/hoop.py
new file mode 100644
--- /dev/null	(date 1747056376640)
+++ b/hungry_goals/entities/hoop.py	(date 1747056376640)
@@ -0,0 +1,70 @@
+# Hungry Buckets
+# Description : Ce fichier gère l’affichage et le positionnement du panier dans le jeu.
+
+import pygame
+import random
+import os
+from hungry_goals.engine.config import SCREEN_WIDTH, SCREEN_HEIGHT, BASKET_COLOR, BACKBOARD_COLOR, ARCEAU_COLOR, PANNEAU_COLOR
+
+
+#
+class Panier:
+    def __init__(self):
+        self.basket_rect = None
+        self.backboard_rect = None
+        self.hoop_center_rect = None
+        self.direction = None
+        self.repositionner()
+
+        filet_path = os.path.join("assets", "image", "filet.png")
+        self.filet_image = pygame.image.load(filet_path).convert_alpha()
+        self.filet_image = pygame.transform.scale(self.filet_image, (64, 36))  # adapte selon besoin
+
+    def draw(self, screen):
+        pygame.draw.rect(screen, ARCEAU_COLOR, self.basket_rect)
+        filet_rect = self.filet_image.get_rect(midtop=(self.basket_rect.centerx - 4, self.basket_rect.bottom - 12))
+        screen.blit(self.filet_image, filet_rect)
+
+        pygame.draw.rect(screen, PANNEAU_COLOR, self.backboard_rect)
+
+    def repositionner(self):
+        """
+        Repositionner dynamiquement le panier à une hauteur aléatoire.
+
+        Aucun paramètre.
+
+        Aucun retour.
+        """
+        # Calcul de la hauteur aléatoire du panier entre une valeur minimale et maximale
+        y = random.randint(200, int(SCREEN_HEIGHT * 0.75))
+
+        # Dimensions des différents éléments du panier
+        basket_width = 70     # largeur de l'arceau (basket)
+        basket_height = 4     # hauteur de l'arceau
+        backboard_width = 10  # largeur du panneau (backboard)
+        backboard_height = 70 # hauteur du panneau
+        hoop_width = 50       # largeur de la zone centrale du panier (hoop)
+        hoop_height = 12      # hauteur de la zone centrale du panier
+
+        # Positionnement des rectangles représentant les différentes parties du panier
+        self.basket_rect = pygame.Rect(SCREEN_WIDTH - 80, y, basket_width, basket_height)
+        self.backboard_rect = pygame.Rect(
+            self.basket_rect.right - backboard_width,
+            self.basket_rect.top - backboard_height + 10,
+            backboard_width,
+            backboard_height
+        )
+        self.hoop_center_rect = pygame.Rect(
+            self.basket_rect.centerx - hoop_width // 2,
+            self.basket_rect.bottom,
+            hoop_width,
+            hoop_height
+        )
+
+    def move_horizontally(self):
+        self.basket_rect.x += self.direction * 2
+        if self.basket_rect.right > SCREEN_WIDTH or self.basket_rect.left < SCREEN_WIDTH // 2:
+            self.direction *= -1
+
+    def get_rects(self):
+        return self.backboard_rect, self.basket_rect, self.hoop_center_rect
\ No newline at end of file
Index: hungry_goals/entities/player1.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/hungry_goals/entities/player1.py b/hungry_goals/entities/player1.py
new file mode 100644
--- /dev/null	(date 1747056376640)
+++ b/hungry_goals/entities/player1.py	(date 1747056376640)
@@ -0,0 +1,161 @@
+# Projet : Hungry Buckets
+# Description : Ce fichier contient la classe Player1, qui gère les animations, mouvements, et actions du personnage joueur 1.
+
+import pygame
+from hungry_goals.utils import *
+import os
+#
+SCALE = 3  # ou 3 pour encore plus grand
+
+class Player1:
+    def __init__(self, x, y):
+        """
+        Initialise un objet Player1 avec sa position, ses propriétés et ses animations.
+
+        Paramètres :
+        - self : instance de la classe Player1
+        - x (int) : position horizontale initiale du joueur
+        - y (int) : position verticale initiale du joueur
+
+        Retour : None
+        """
+        # Initialisation des attributs de position et animation
+        self.x = x
+        self.y = y
+        self.radius = 20
+        self.color = (0, 100, 255)
+        self.speed = 6
+        self.frame_index = 0
+        self.animation_speed = 0.4
+
+        # Chargement de la sprite sheet
+        base_path = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+        image_path = os.path.join(base_path, "assets", "image", "Character.png")
+        self.sprite_sheet = pygame.image.load(image_path).convert_alpha()
+
+        # Chargement des différentes animations (idle, right, left, shoot, special)
+        self.frames_idle = load_frames(self.sprite_sheet, row=2, num_frames=23, width=64, height=64)
+        self.frames_right = load_combined_frames(self.sprite_sheet, rows=[8, 9], num_frames_per_row=[7, 20], width=64,height=64)
+        self.frames_left = [pygame.transform.flip(f, True, False) for f in self.frames_right]  # dribble gauche
+
+        self.frames_shoot = load_frames(self.sprite_sheet,3, 5, width=64, height=64)
+        self.frames_special = load_frames(self.sprite_sheet, row=7, num_frames=11, width=64, height=64)
+
+        # Initialisation de l’état et frame actuelle
+        self.state = "idle"
+        self.shooting_done = False
+
+        self.frames = self.frames_idle
+        self.current_frame = self.frames_idle[self.frame_index]
+
+    def start_shoot(self):
+        """
+        Démarre l'animation de tir si le joueur n'est pas déjà en train de tirer.
+
+        Paramètres :
+        - self : instance de la classe Player1
+
+        Retour : None
+        """
+        if self.state != "shoot":
+            self.frames = self.frames_shoot
+            self.frame_index = 0
+            self.state = "shoot"
+            self.shooting_done = False
+
+    def start_special(self):
+        """
+        Démarre l'animation spéciale si le joueur n'est pas déjà en animation spéciale.
+
+        Paramètres :
+        - self : instance de la classe Player1
+
+        Retour : None
+        """
+        if self.state != "special":
+            self.frames = self.frames_special
+            self.frame_index = 0
+            self.state = "special"
+            self.shooting_done = False
+
+    def handle_input(self, keys, screen_width):
+        """
+        Gère les entrées clavier pour déplacer le joueur ou lancer des animations.
+
+        Paramètres :
+        - self : instance de la classe Player1
+        - keys : liste ou dictionnaire des touches pressées (ex : pygame.key.get_pressed())
+        - screen_width (int) : largeur de l'écran pour limiter le déplacement horizontal
+
+        Retour : None
+        """
+
+        # Si une animation de tir ou spéciale est en cours, on la joue jusqu'au bout sans interruption
+        if self.state in ["shoot", "special"]:
+            if not self.shooting_done:
+                # Met à jour l'animation image par image
+                self.frame_index, self.current_frame = update_animation(self.frame_index, self.frames,
+                                                                        self.animation_speed)
+                if int(self.frame_index) >= len(self.frames) - 1:
+                    # Arrête l'animation à la dernière image
+                    self.frame_index = len(self.frames) - 1
+                    self.current_frame = self.frames[self.frame_index]
+                    self.shooting_done = True
+            return  # On ne gère pas les déplacements pendant ces animations
+
+        moving = False  # Sert à détecter si le joueur bouge
+
+        # Gestion du déplacement vers la gauche
+        if keys[pygame.K_LEFT]:
+            if self.frames != self.frames_left:
+                self.frames = self.frames_left  # Active l'animation correspondante
+                self.frame_index = 0
+            self.x -= self.speed
+            moving = True
+
+        # Gestion du déplacement vers la droite
+        elif keys[pygame.K_RIGHT]:
+            if self.frames != self.frames_right:
+                self.frames = self.frames_right
+                self.frame_index = 0
+            self.x += self.speed
+            moving = True
+
+        # Si aucune touche directionnelle n’est pressée : on revient à l’état "idle"
+        else:
+            if self.frames != self.frames_idle:
+                self.frames = self.frames_idle
+                self.frame_index = 0
+
+        # Mise à jour de l'animation (idle ou déplacement)
+        self.frame_index, self.current_frame = update_animation(self.frame_index, self.frames, self.animation_speed)
+
+        # Empêche le joueur de sortir de l'écran horizontalement
+        self.x = max(self.radius, min(screen_width - self.radius, self.x))
+
+
+    def draw(self, surface):
+        """
+        Dessine le joueur sur la surface donnée.
+
+        Paramètres :
+        - self : instance de la classe Player1
+        - surface : surface pygame sur laquelle dessiner le joueur
+
+        Retour : None
+        """
+        self.rect = self.current_frame.get_rect(center=(self.x, self.y))
+        surface.blit(self.current_frame, self.rect)
+
+
+    def get_position(self):
+        """
+        Retourne la position actuelle du joueur.
+
+        Paramètres :
+        - self : instance de la classe Player1
+
+        Retour :
+        - tuple (x, y) : position actuelle du joueur
+        """
+        return (self.x, self.y)
\ No newline at end of file
